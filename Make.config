include $(TOP)/mk/subdirs.mk

# calculate commit distance and store it in a file so that we don't have to re-calculate it every time make is executed.

-include $(TOP)/Make.config.inc
$(TOP)/Make.config.inc: $(TOP)/Make.config $(TOP)/mk/mono.mk
	@rm -f $@
	@printf "IOS_COMMIT_DISTANCE:=$(shell LANG=C; export LANG && git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep IOS_PACKAGE_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@printf "MAC_COMMIT_DISTANCE:=$(shell LANG=C; export LANG && git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep MAC_PACKAGE_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@printf "IOS_NUGET_COMMIT_DISTANCE:=$(shell LANG=C; export LANG; git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep IOS_NUGET_OS_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@printf "TVOS_NUGET_COMMIT_DISTANCE:=$(shell LANG=C; export LANG; git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep TVOS_NUGET_OS_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@printf "WATCHOS_NUGET_COMMIT_DISTANCE:=$(shell LANG=C; export LANG; git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep WATCHOS_NUGET_OS_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@printf "MACOS_NUGET_COMMIT_DISTANCE:=$(shell LANG=C; export LANG; git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep MACOS_NUGET_OS_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@printf "MACCATALYST_NUGET_COMMIT_DISTANCE:=$(shell LANG=C; export LANG; git --git-dir $(TOP)/.git log `git --git-dir $(TOP)/.git blame -- ./Make.versions HEAD | grep MACCATALYST_NUGET_OS_VERSION= | sed 's/ .*//' `..HEAD --oneline | wc -l | sed 's/ //g')\n" >> $@
	@if which ccache > /dev/null 2>&1; then printf "ENABLE_CCACHE=1\nexport CCACHE_BASEDIR=$(abspath $(TOP)/..)\n" >> $@; echo "Found ccache on the system, enabling it"; fi
	@if test -d $(TOP)/../maccore; then printf "ENABLE_XAMARIN=1\n" >> $@; echo "Detected the maccore repository, automatically enabled the Xamarin build"; fi
	@# Build from source if we're on CI and packages aren't available.
	@if ! curl -s -f --head "$(MONO_IOS_URL)" &> /dev/null; then \
		echo "$(COLOR_GRAY)*** The mono archive for iOS ($(MONO_IOS_URL)) can't be downloaded:$(COLOR_CLEAR)"; \
		echo "$$ curl -s --head '$(MONO_IOS_URL)'" | sed 's/^/    /'; \
		curl -s --head "$(MONO_IOS_URL)" | sed 's/^/    /'; \
		MONO_DOWNLOAD_FAIL=1; \
	fi; \
	if ! curl -s -f --head "$(MONO_MAC_URL)" &> /dev/null; then \
		echo "$(COLOR_GRAY)*** The mono archive for macOS ($(MONO_MAC_URL)) can't be downloaded:$(COLOR_CLEAR)"; \
		echo "$$ curl -s --head '$(MONO_MAC_URL)'" | sed 's/^/    /'; \
		curl -s --head "$(MONO_MAC_URL)" | sed 's/^/    /'; \
		MONO_DOWNLOAD_FAIL=1; \
	fi; \
	if test -n "$$MONO_DOWNLOAD_FAIL"; then \
		echo "$(COLOR_GRAY)Building mono from source because one or both of the mono archives aren't downloadable.$(COLOR_CLEAR)"; \
		printf "MONO_BUILD_FROM_SOURCE=1\n" >> $@; \
	else \
		echo "Downloading mono archives"; \
	fi

include $(TOP)/Make.versions

APIDIFF_REFERENCES_iOS=https://bosstoragemirror.blob.core.windows.net/wrench/d17-3/87f98a75edaa6757fd6ff5170d297615830fb41b/6466144/package/bundle.zip
APIDIFF_REFERENCES_Mac=https://bosstoragemirror.blob.core.windows.net/wrench/d17-3/87f98a75edaa6757fd6ff5170d297615830fb41b/6466144/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_iOS=https://bosstoragemirror.blob.core.windows.net/wrench/6.0.4xx/4bd34d034c8c5a4e092c8bd3c8868153d94277b4/6656178/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_tvOS=https://bosstoragemirror.blob.core.windows.net/wrench/6.0.4xx/4bd34d034c8c5a4e092c8bd3c8868153d94277b4/6656178/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_macOS=https://bosstoragemirror.blob.core.windows.net/wrench/6.0.4xx/4bd34d034c8c5a4e092c8bd3c8868153d94277b4/6656178/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_MacCatalyst=https://bosstoragemirror.blob.core.windows.net/wrench/6.0.4xx/4bd34d034c8c5a4e092c8bd3c8868153d94277b4/6656178/package/bundle.zip

PACKAGE_HEAD_REV=$(shell git rev-parse HEAD)

#
# /!\ README /!\
#
# A release branch requires updating some variables.
# This is done in Make.versions, not here.
#

ifeq ($(BRANCH_NAME),)
# BRANCH_NAME is set in Jenkins, so this is for local builds.
CURRENT_BRANCH:=$(shell git rev-parse --abbrev-ref HEAD)
else
CURRENT_BRANCH:=$(BRANCH_NAME)
endif
CURRENT_BRANCH_SED_ESCAPED:=$(subst |,\|,$(subst &,\&,$(subst $$,\$$,$(subst /,\/,$(CURRENT_BRANCH)))))
# The branch name in the nuget version has to be alphanumeric, and we follow the semantic versioning spec,
# which defines "alphanumeric" as the letters, numbers and the dash character (and nothing else).
# So here we replace all non-alphanumeric characters in the branch name with a dash.
CURRENT_BRANCH_ALPHANUMERIC:=$(shell export LANG=C; printf "%s" "$(CURRENT_BRANCH)" | tr -c '[a-zA-Z0-9-]' '-')

# Get the current hash
CURRENT_HASH:=$(shell git log -1 --pretty=%h)

# Get the pull request number, if this is a pull request
# Jenkins may set either CHANGE_ID or ghprbPullId
# Azure Devops sets SYSTEM_PULLREQUEST_PULLREQUESTNUMBER
ifneq ($(CHANGE_ID),)
PULL_REQUEST_ID=$(CHANGE_ID)
else ifneq ($(ghprbPullId),)
PULL_REQUEST_ID=$(ghprbPullId)
else ifneq ($(SYSTEM_PULLREQUEST_PULLREQUESTNUMBER),)
PULL_REQUEST_ID=$(SYSTEM_PULLREQUEST_PULLREQUESTNUMBER)
endif

# We have three types of branches:
#
# 1. Release (stable) branches. These have stable versioning (no prerelease identifiers).
# 2. Pre-release branches. These have stable versioning + prerelease identifiers.
# 3. Any other branches, These have CI/PR versioning.
#
# * A PR branch (case 3 above) is identified by the PULL_REQUEST_ID variable
#   (set in the environment). This takes precedence over any other variable.
# * Otherwise a release branch (case 1 above) is identified by setting the
#   NUGET_RELEASE_BRANCH variable to the name of the release branch (this
#   seems redundant: why should a branch name itself? but it's important if
#   another branch is created from the release branch: that other branch might
#   be any other random branch for whatever purpose, and shouldn't be
#   considered a release branch just because someone forgot to unset a
#   variable).
# * Otherwise a prerelease branch (case 2 above) is identified by the
#   NUGET_HARDCODED_PRERELEASE_IDENTIFIER variable, which is used to hardcode
#   a prerelease version. Note that NUGET_HARDCODED_PRERELEASE_BRANCH must
#   also be set to the name of the current branch, otherwise
#   NUGET_HARDCODED_PRERELEASE_IDENTIFIER will be ignored.
# * Otherwise we're a CI branch (case 3 above).

## If this branch is a release branch, set NUGET_RELEASE_BRANCH to the exact branch name (so that any other branches won't become release branches just by branching off from a release branch).
## Example: release/6.0.3xx
# NUGET_RELEASE_BRANCH=

## If this is a pre-release (alpha, beta, rc, xcode, etc.) branch, set NUGET_HARDCODED_PRERELASE_BRANCH to the exact branch name. Also set NUGET_HARDCODED_PRELEASE_IDENTIFIER to the prerelease identifier to use.
## Example:
##   NUGET_HARDCODED_PRERELEASE_BRANCH=release/6.0.3xx-rc3
##   NUGET_HARDCODED_PRERELEASE_IDENTIFIER=rc.3
## Example 2: we might sometimes make 'main' a prerelease branch:
##   NUGET_HARDCODED_PRERELEASE_BRANCH=main
##   NUGET_HARDCODED_PRERELEASE_IDENTIFIER=rc.4
## In this case, when we create an actual rc4 branch, the value for
## NUGET_HARDCODED_PRERELEASE_IDENTIFIER in main must be changed to "rc.5" (or
## anything else), while the value for NUGET_HARDCODED_PRERELEASE_BRANCH in
## the rc4 branch will become the rc4 branch name. The value in main must
## change *first*, otherwise we'll produce builds with the same version from
## two different branches (which is very, very bad).
##
# NUGET_HARDCODED_PRERELEASE_IDENTIFIER=rc.3
# NUGET_HARDCODED_PRERELEASE_BRANCH=release/6.0.3xx

# compute the alphanumeric version of branch names
NUGET_RELEASE_BRANCH_ALPHANUMERIC:=$(shell export LANG=C; printf "%s" "$(NUGET_RELEASE_BRANCH)" | tr -c '[a-zA-Z0-9-]' '-')
NUGET_HARDCODED_PRERELEASE_BRANCH_ALPHANUMERIC:=$(shell export LANG=C; printf "%s" "$(NUGET_HARDCODED_PRERELEASE_BRANCH)" | tr -c '[a-zA-Z0-9-]' '-')

# Compute the prerelease identifier based on the variables above
# DO NOT MODIFY THE BELOW CONDITIONS TO HARDCODE A VERSION NUMBER FOR (PRE)RELEASE BRANCHES.
# READ INSTRUCTIONS ABOVE INSTEAD.
ifneq ($(PULL_REQUEST_ID),)
# we're a PR, so PR versioning
NUGET_PRERELEASE_IDENTIFIER=-ci.pr.gh$(PULL_REQUEST_ID)
else ifeq ($(NUGET_RELEASE_BRANCH_ALPHANUMERIC),$(CURRENT_BRANCH_ALPHANUMERIC))
# this is a release branch, so no prerelease identifier
NUGET_PRERELEASE_IDENTIFIER=
else ifeq ($(NUGET_HARDCODED_PRERELEASE_BRANCH_ALPHANUMERIC),$(CURRENT_BRANCH_ALPHANUMERIC))
# this is a prerelease branch!
NUGET_PRERELEASE_IDENTIFIER=-$(NUGET_HARDCODED_PRERELEASE_IDENTIFIER)
else
# this is a CI branch!
NUGET_PRERELEASE_IDENTIFIER=-ci.$(CURRENT_BRANCH_ALPHANUMERIC)
endif

NUGET_BUILD_METADATA=sha.$(CURRENT_HASH)

IOS_PRODUCT=Xamarin.iOS
IOS_PACKAGE_NAME=Xamarin.iOS
IOS_PACKAGE_NAME_LOWER=$(shell echo $(IOS_PACKAGE_NAME) | tr "[:upper:]" "[:lower:]")
IOS_PACKAGE_VERSION_MAJOR=$(word 1, $(subst ., ,$(IOS_PACKAGE_VERSION)))
IOS_PACKAGE_VERSION_MINOR=$(word 2, $(subst ., ,$(IOS_PACKAGE_VERSION)))
IOS_PACKAGE_VERSION_REV:=$(word 3, $(subst ., ,$(IOS_PACKAGE_VERSION)))
IOS_PACKAGE_VERSION_BUILD=$(IOS_COMMIT_DISTANCE)
IOS_PACKAGE_UPDATE_ID=$(shell printf "2%02d%02d%02d%03d" $(IOS_PACKAGE_VERSION_MAJOR) $(IOS_PACKAGE_VERSION_MINOR) $(IOS_PACKAGE_VERSION_REV) $(IOS_PACKAGE_VERSION_BUILD))

IOS_NUGET=Microsoft.iOS
IOS_NUGET_VERSION=$(IOS_NUGET_OS_VERSION).$(IOS_NUGET_COMMIT_DISTANCE)
IOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(IOS_NUGET_VERSION)))
IOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(IOS_NUGET_VERSION)))
IOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(IOS_NUGET_VERSION)))
IOS_NUGET_VERSION_NO_METADATA=$(IOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
IOS_NUGET_VERSION_FULL=$(IOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

IOS_WINDOWS_NUGET=Microsoft.iOS.Windows
IOS_WINDOWS_NUGET_VERSION_MAJOR=$(IOS_NUGET_VERSION_MAJOR)
IOS_WINDOWS_NUGET_VERSION_MINOR=$(IOS_NUGET_VERSION_MINOR)
IOS_WINDOWS_NUGET_VERSION_PATCH=$(IOS_NUGET_VERSION_PATCH)
IOS_WINDOWS_NUGET_VERSION_NO_METADATA=$(IOS_NUGET_VERSION_NO_METADATA)
IOS_WINDOWS_NUGET_VERSION_FULL=$(IOS_NUGET_VERSION_FULL)

TVOS_NUGET=Microsoft.tvOS
TVOS_NUGET_VERSION=$(TVOS_NUGET_OS_VERSION).$(TVOS_NUGET_COMMIT_DISTANCE)
TVOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(TVOS_NUGET_VERSION)))
TVOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(TVOS_NUGET_VERSION)))
TVOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(TVOS_NUGET_VERSION)))
TVOS_NUGET_VERSION_NO_METADATA=$(TVOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
TVOS_NUGET_VERSION_FULL=$(TVOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

WATCHOS_NUGET=Microsoft.watchOS
WATCHOS_NUGET_VERSION=$(WATCHOS_NUGET_OS_VERSION).$(WATCHOS_NUGET_COMMIT_DISTANCE)
WATCHOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
WATCHOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
WATCHOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
WATCHOS_NUGET_VERSION_NO_METADATA=$(WATCHOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
WATCHOS_NUGET_VERSION_FULL=$(WATCHOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

MACCATALYST_NUGET=Microsoft.MacCatalyst
MACCATALYST_NUGET_VERSION=$(MACCATALYST_NUGET_OS_VERSION).$(MACCATALYST_NUGET_COMMIT_DISTANCE)
MACCATALYST_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_NUGET_VERSION_NO_METADATA=$(MACCATALYST_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
MACCATALYST_NUGET_VERSION_FULL=$(MACCATALYST_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

# Xcode version should have both a major and a minor version (even if the minor version is 0)
XCODE_VERSION=13.3
XCODE_URL=https://dl.internalx.com/internal-files/xcodes/Xcode_13.3.xip
XCODE_DEVELOPER_ROOT=/Applications/Xcode_13.3.0.app/Contents/Developer
XCODE_PRODUCT_BUILD_VERSION:=$(shell /usr/libexec/PlistBuddy -c 'Print :ProductBuildVersion' $(XCODE_DEVELOPER_ROOT)/../version.plist 2>/dev/null || echo "    $(shell tput setaf 1 2>/dev/null)The required Xcode ($(XCODE_VERSION)) is not installed in $(basename $(basename $(XCODE_DEVELOPER_ROOT)))$(shell tput sgr0 2>/dev/null)" >&2)

# Tell both Xcode and our build logic which Xcode we're using.
export DEVELOPER_DIR=$(XCODE_DEVELOPER_ROOT)
export MD_APPLE_SDK_ROOT=$(abspath $(XCODE_DEVELOPER_ROOT)/../..)

# We don't need to be told there are workload updates
export DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE=true
# We don't need to be told we're using preview packages (we pretty much always are).
export SuppressNETCoreSdkPreviewMessage=true

# Mono version embedded in XI/XM (NEEDED_MONO_VERSION/BRANCH) are specified in mk/mono.mk
include $(TOP)/mk/mono.mk
MONO_HASH := $(NEEDED_MONO_VERSION)

# Minimum Mono version for building XI/XM
MIN_MONO_VERSION=6.12.0.179
MAX_MONO_VERSION=6.12.99
MIN_MONO_URL=https://xamjenkinsartifact.azureedge.net/build-package-osx-mono/2020-02/185/dffa5ab92245f2419238a35b7c2052e9a24036b4/MonoFramework-MDK-6.12.0.179.macos10.xamarin.universal.pkg

# Minimum Mono version for Xamarin.Mac apps using the system mono
MIN_XM_MONO_VERSION=6.4.0.94
MIN_XM_MONO_URL=https://xamjenkinsartifact.azureedge.net/build-package-osx-mono/2019-06/77/c608cf3eafaea310e11af13cc9380d770112bb83/MonoFramework-MDK-6.4.0.94.macos10.xamarin.universal.pkg

# Minimum CMake version
MIN_CMAKE_URL=https://cmake.org/files/v3.6/cmake-3.6.2-Darwin-x86_64.dmg
MIN_CMAKE_VERSION=2.8.8

# ObjectiveSharpie min/max versions
MIN_SHARPIE_VERSION=3.5.50
MAX_SHARPIE_VERSION=3.5.99
MIN_SHARPIE_URL=https://download.visualstudio.microsoft.com/download/pr/401d21b7-58c2-4f86-9009-76c15bf9a804/fd5dc34d033d9949a378ca4b3332c02c/objectivesharpie-3.5.50.pkg

# Minimum OSX versions for building XI/XM
MIN_OSX_BUILD_VERSION=12.0
# Minimum OSX version for executing XI/XM tooling.
MIN_OSX_VERSION_FOR_IOS=10.11
MIN_OSX_VERSION_FOR_MAC=10.11

# Bump the *_NUGET_VERSION variables in Make.versions instead, because that makes sure the computed commit distance for the version is correct.
IOS_SDK_VERSION=$(word 1, $(subst ., ,$(IOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(IOS_NUGET_VERSION)))
MACOS_SDK_VERSION=$(word 1, $(subst ., ,$(MACOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(MACOS_NUGET_VERSION)))
WATCH_SDK_VERSION=$(word 1, $(subst ., ,$(WATCHOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
TVOS_SDK_VERSION=$(word 1, $(subst ., ,$(TVOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(TVOS_NUGET_VERSION)))
MACCATALYST_SDK_VERSION=$(word 1, $(subst ., ,$(MACCATALYST_NUGET_VERSION))).$(word 2, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_MAC_SDK_VERSION=$(MACOS_SDK_VERSION)

MAX_IOS_DEPLOYMENT_TARGET=$(IOS_SDK_VERSION)
MAX_WATCH_DEPLOYMENT_TARGET=$(WATCH_SDK_VERSION)
MAX_TVOS_DEPLOYMENT_TARGET=$(TVOS_SDK_VERSION)

MAX_IOS_SIMULATOR_VERSION=$(IOS_SDK_VERSION)
MAX_TVOS_SIMULATOR_VERSION=$(TVOS_SDK_VERSION)
MAX_WATCH_SIMULATOR_VERSION=$(WATCH_SDK_VERSION)

# Minimum OS versions for running XI/XM apps.
MIN_IOS_SDK_VERSION=7.0
MIN_MACOS_SDK_VERSION=10.9
MIN_WATCHOS_SDK_VERSION=2.0
MIN_WATCHOS64_32_SDK_VERSION=5.1
MIN_WATCH_OS_VERSION=2.0
MIN_TVOS_SDK_VERSION=9.0
MIN_MACCATALYST_SDK_VERSION=13.1

# Minimum OS versions for dotnet6 support
DOTNET_MIN_IOS_SDK_VERSION=10.0
DOTNET_MIN_TVOS_SDK_VERSION=10.0
DOTNET_MIN_MACCATALYST_SDK_VERSION=13.1
DOTNET_MIN_MACOS_SDK_VERSION=10.14

# The min simulator version available in the Xcode we're using
MIN_IOS_SIMULATOR_VERSION=12.4
MIN_WATCHOS_SIMULATOR_VERSION=6.0
# This is the iOS version that matches the watchOS version (i.e same Xcode)
MIN_WATCHOS_COMPANION_SIMULATOR_VERSION=12.4
MIN_TVOS_SIMULATOR_VERSION=12.4
# These are the simulator package ids for the versions above
EXTRA_SIMULATORS=com.apple.pkg.iPhoneSimulatorSDK12_4 com.apple.pkg.AppleTVSimulatorSDK12_4 com.apple.pkg.WatchSimulatorSDK6_0

INCLUDE_IOS=1
INCLUDE_MAC=1
INCLUDE_WATCH=1
INCLUDE_TVOS=1
INCLUDE_MACCATALYST=1
INCLUDE_DEVICE=1
INCLUDE_DOTNET_WATCHOS=
INCLUDE_XAMARIN_LEGACY=1
INCLUDE_HOTRESTART=1

ENABLE_DOTNET=1

# disable source code install by default (it's enabled for CI builds)
ENABLE_INSTALL_SOURCE=

-include $(TOP)/Make.config.local
-include $(TOP)/configure.inc

ifdef ENABLE_CCACHE
# Note the space at the end the line
CCACHE=ccache 
endif

XCODE_MAC_SDKROOT=$(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk

# The MAC_* variables do not contain the -mmacosx-version-min flag on purpose: each usage must specify it separately.
MAC_CC=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -isysroot $(XCODE_MAC_SDKROOT) -stdlib=libc++
MAC_CXX=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -isysroot $(XCODE_MAC_SDKROOT) -stdlib=libc++

MAC_INSTALL_VERSION ?= git
IOS_INSTALL_VERSION ?= git

ifneq ($(TESTS_USE_SYSTEM),)
IOS_DESTDIR ?= /
else
IOS_DESTDIR ?= $(TOP)/_ios-build
endif
IOS_TARGETDIR ?= $(IOS_DESTDIR)

USE_SOURCE_LINKS ?= 1

IOS_FRAMEWORK_DIR=/Library/Frameworks/Xamarin.iOS.framework
# Prefix used to install monotouch
ifndef MONOTOUCH_PREFIX
  MONOTOUCH_PREFIX=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_INSTALL_VERSION)
endif

XCODE_CC=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
XCODE_CXX=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++

# make sure we have full paths. The patsubst function is to remove any trailing slash (this may leave the variable empty)
override IOS_DESTDIR := $(patsubst %/,%,$(abspath $(IOS_DESTDIR)))
override IOS_TARGETDIR := $(patsubst %/,%,$(abspath $(IOS_TARGETDIR)))
MONOTOUCH_PREFIX := $(abspath $(MONOTOUCH_PREFIX))

MONOTOUCH_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.iOS
MONOTOUCH_TV_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.TVOS
MONOTOUCH_WATCH_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.WatchOS
MONOTOUCH_MACCATALYST_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.MacCatalyst

IOS_PACKAGE_FILENAME=$(IOS_PACKAGE_NAME_LOWER)-$(IOS_PACKAGE_VERSION).pkg
IOS_PACKAGE_UTI=com.xamarin.$(IOS_PACKAGE_NAME_LOWER).pkg

IOS_COMMON_DEFINES=-DMONOTOUCH

IOS_CC=$(XCODE_CC)
IOS_CXX=$(XCODE_CXX)
SIMULATOR_BIN_PATH=$(XCODE_DEVELOPER_ROOT)/Platforms/iPhoneSimulator.platform/Developer/usr/bin
SIMULATOR_CC=$(IOS_CC)

CFLAGS= -Wall -fms-extensions -Werror -Wconversion -Wdeprecated -Wuninitialized -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security

ifdef ENABLE_BITCODE_ON_IOS
BITCODE_CFLAGS=-fembed-bitcode-marker
# Overwrite the default
MIN_IOS_SDK_VERSION=9.0
endif

SIMULATOR_SDK=$(XCODE_DEVELOPER_ROOT)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator$(IOS_SDK_VERSION).sdk

OBJC_CFLAGS=-ObjC++ -std=c++14 -fno-exceptions -stdlib=libc++

COMMON_SIMULATOR_CFLAGS=-mios-simulator-version-min=$(MIN_IOS_SDK_VERSION) -isysroot $(SIMULATOR_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATOR86_CFLAGS=$(COMMON_SIMULATOR_CFLAGS) -arch i386
SIMULATOR64_CFLAGS=$(COMMON_SIMULATOR_CFLAGS) -arch x86_64
SIMULATOR_ARM64_CFLAGS=$(COMMON_SIMULATOR_CFLAGS) -arch arm64
COMMON_SIMULATOR_OBJC_CFLAGS=-fobjc-abi-version=2 -fobjc-legacy-dispatch $(CFLAGS) $(OBJC_CFLAGS)
SIMULATOR86_OBJC_CFLAGS=$(COMMON_SIMULATOR_OBJC_CFLAGS) $(SIMULATOR86_CFLAGS)
SIMULATOR64_OBJC_CFLAGS=$(COMMON_SIMULATOR_OBJC_CFLAGS) $(SIMULATOR64_CFLAGS)
SIMULATOR_ARM64_OBJC_CFLAGS=$(COMMON_SIMULATOR_OBJC_CFLAGS) $(SIMULATOR_ARM64_CFLAGS)

MACCATALYST_COMMON_CFLAGS=-target x86_64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch x86_64 -g $(IOS_COMMON_DEFINES) \
	-isysroot $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk \
	-isystem $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/usr/include \
	-iframework $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/System/Library/Frameworks
MACCATALYST_OBJC_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -fobjc-abi-version=2 -fobjc-legacy-dispatch $(OBJC_CFLAGS)
MACCATALYST_CFLAGS=$(MACCATALYST_COMMON_CFLAGS)

MACCATALYST_COMMON_CFLAGS=$(CFLAGS) -g $(IOS_COMMON_DEFINES) \
	-isysroot $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk \
	-isystem $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/usr/include \
	-iframework $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/System/Library/Frameworks
MACCATALYST_COMMON_OBJC_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -fobjc-abi-version=2 -fobjc-legacy-dispatch $(OBJC_CFLAGS)
MACCATALYST_X86_64_OBJC_CFLAGS=$(MACCATALYST_COMMON_OBJC_CFLAGS) -target x86_64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch x86_64
MACCATALYST_X86_64_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -target x86_64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch x86_64
MACCATALYST_ARM64_OBJC_CFLAGS=$(MACCATALYST_COMMON_OBJC_CFLAGS) -target arm64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch arm64
MACCATALYST_ARM64_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -target arm64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch arm64

MONOTOUCH_SIMULATOR_SDK=$(MONOTOUCH_PREFIX)/SDKs/MonoTouch.iphonesimulator.sdk

DEVICE_BIN_PATH=$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin
DEVICE_CC=$(IOS_CC)
DEVICE_CXX=$(IOS_CXX)

IOS_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_MONO_PATH)/System.dll -r:$(MONOTOUCH_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic
TV_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_TV_MONO_PATH)/System.dll -r:$(MONOTOUCH_TV_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_TV_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_TV_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_TV_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_TV_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic
WATCH_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic
MACCATALYST_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic

DEVICE_OBJC_CFLAGS=$(OBJC_CFLAGS) $(BITCODE_CFLAGS)

DEVICE_SDK=$(XCODE_DEVELOPER_ROOT)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS$(IOS_SDK_VERSION).sdk
DEVICE7_CFLAGS= -arch armv7  -mno-thumb -miphoneos-version-min=$(MIN_IOS_SDK_VERSION) -isysroot $(DEVICE_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICE7S_CFLAGS=-arch armv7s -mno-thumb -miphoneos-version-min=$(MIN_IOS_SDK_VERSION) -isysroot $(DEVICE_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICE64_CFLAGS=-arch arm64             -miphoneos-version-min=7.0                    -isysroot $(DEVICE_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICE7_OBJC_CFLAGS =$(DEVICE7_CFLAGS)  $(DEVICE_OBJC_CFLAGS)
DEVICE7S_OBJC_CFLAGS=$(DEVICE7S_CFLAGS) $(DEVICE_OBJC_CFLAGS)
DEVICE64_OBJC_CFLAGS=$(DEVICE64_CFLAGS) $(DEVICE_OBJC_CFLAGS)
MONOTOUCH_DEVICE_SDK=$(MONOTOUCH_PREFIX)/SDKs/MonoTouch.iphoneos.sdk

# iOS

XAMARIN_IOSSIMULATOR_SDK = $(MONOTOUCH_SIMULATOR_SDK)
XAMARIN_IPHONEOS_SDK     = $(MONOTOUCH_DEVICE_SDK)

# MacCatalyst

XAMARIN_MACCATALYST_SDK    = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.MacCatalyst.sdk

# WatchOS 

XAMARIN_WATCHSIMULATOR_SDK = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.WatchSimulator.sdk
XAMARIN_WATCHOS_SDK        = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.WatchOS.sdk

SIMULATORWATCH_SDK           = $(XCODE_DEVELOPER_ROOT)/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator$(WATCH_SDK_VERSION).sdk
SIMULATORWATCH_CFLAGS        = -arch i386 -mwatchos-simulator-version-min=$(MIN_WATCHOS_SDK_VERSION) -isysroot $(SIMULATORWATCH_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORWATCH64_CFLAGS      = -arch x86_64 -mwatchos-simulator-version-min=$(MIN_WATCHOS_SDK_VERSION) -isysroot $(SIMULATORWATCH_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORWATCH_OBJC_CFLAGS   = $(SIMULATORWATCH_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS) 
SIMULATORWATCH64_OBJC_CFLAGS = $(SIMULATORWATCH64_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS) 

DEVICEWATCH_SDK         = $(XCODE_DEVELOPER_ROOT)/Platforms/WatchOS.platform/Developer/SDKs/WatchOS$(WATCH_SDK_VERSION).sdk
DEVICEWATCH_CFLAGS      = -arch armv7k -mwatchos-version-min=$(MIN_WATCHOS_SDK_VERSION) -isysroot $(DEVICEWATCH_SDK) $(CFLAGS) -fembed-bitcode $(IOS_COMMON_DEFINES)
DEVICEWATCH64_32_CFLAGS = -arch arm64_32 -mwatchos-version-min=$(MIN_WATCHOS64_32_SDK_VERSION) -isysroot $(DEVICEWATCH_SDK) $(CFLAGS) -fembed-bitcode $(IOS_COMMON_DEFINES)
DEVICEWATCH_OBJC_CFLAGS = $(DEVICEWATCH_CFLAGS) $(DEVICE_OBJC_CFLAGS)
DEVICEWATCH64_32_OBJC_CFLAGS = $(DEVICEWATCH64_32_CFLAGS) $(DEVICE_OBJC_CFLAGS)

# TVOS

XAMARIN_TVSIMULATOR_SDK    = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.AppleTVSimulator.sdk
XAMARIN_TVOS_SDK           = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.AppleTVOS.sdk

SIMULATORTV_SDK            = $(XCODE_DEVELOPER_ROOT)/Platforms/AppleTVSimulator.platform/Developer/SDKs/AppleTVSimulator$(TVOS_SDK_VERSION).sdk
SIMULATORTV_CFLAGS         = -arch x86_64 -mtvos-simulator-version-min=$(MIN_TVOS_SDK_VERSION) -isysroot $(SIMULATORTV_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORTV_ARM64_CFLAGS   = -arch arm64  -mtvos-simulator-version-min=$(MIN_TVOS_SDK_VERSION) -isysroot $(SIMULATORTV_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORTV_OBJC_CFLAGS    = $(SIMULATORTV_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS) 
SIMULATORTV_ARM64_OBJC_CFLAGS = $(SIMULATORTV_ARM64_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS)

DEVICETV_SDK               = $(XCODE_DEVELOPER_ROOT)/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS$(TVOS_SDK_VERSION).sdk
DEVICETV_CFLAGS            = -arch arm64 -mtvos-version-min=$(MIN_TVOS_SDK_VERSION) -isysroot $(DEVICETV_SDK) $(CFLAGS) -fembed-bitcode $(IOS_COMMON_DEFINES)
DEVICETV_OBJC_CFLAGS       = $(DEVICETV_CFLAGS) $(DEVICE_OBJC_CFLAGS)

# macOS

XAMARIN_MACOS_SDK = $(MAC_FRAMEWORK_CURRENT_DIR)/SDKs/Xamarin.macOS.sdk

MAC_OBJC_CFLAGS= -mmacosx-version-min=$(MIN_MACOS_SDK_VERSION) -DMONOMAC -DMIN_XM_MONO_VERSION=\"$(MIN_XM_MONO_VERSION)\" $(CFLAGS) $(OBJC_CFLAGS)
MAC_CFLAGS = -mmacosx-version-min=$(MIN_MACOS_SDK_VERSION) -DMONOMAC -g -DMIN_XM_MONO_VERSION=\"$(MIN_XM_MONO_VERSION)\" $(CFLAGS)
MAC_LDFLAGS = -mmacosx-version-min=$(MIN_MACOS_SDK_VERSION) -framework AppKit

# paths to the modules we depend on, as variables, so people can put
# things in other places if they absolutely must.
MONO_PATH=$(TOP)/external/mono
TOUCH_UNIT_PATH=$(TOP)/external/Touch.Unit
OPENTK_PATH=$(TOP)/external/opentk
XAMARIN_MACDEV_PATH=$(TOP)/external/Xamarin.MacDev
MACCORE_PATH=$(TOP)/../maccore
MACIOS_BINARIES_PATH=$(TOP)/external/macios-binaries
IKVM_PATH=$(TOP)/external/ikvm-fork
MONOTOUCH_DIALOG_PATH=$(TOP)/external/MonoTouch.Dialog
API_TOOLS_PATH=$(TOP)/external/api-tools

MONO_PREFIX ?= /Library/Frameworks/Mono.framework/Versions/Current
SYSTEM_MCS=$(MONO_PREFIX)/bin/mcs
SYSTEM_CSC=$(MONO_PREFIX)/bin/csc
SYSTEM_SN=$(MONO_PREFIX)/bin/sn
SYSTEM_MONO=$(MONO_PREFIX)/bin/mono
SYSTEM_MONO32=$(MONO_PREFIX)/bin/mono32
SYSTEM_XBUILD=$(MONO_PREFIX)/bin/msbuild /p:Features=strict /m
SYSTEM_MSBUILD=unset MSBuildExtensionsPath && $(MONO_PREFIX)/bin/msbuild /p:Features=strict /m
SYSTEM_RESGEN=$(MONO_PREFIX)/bin/resgen

XIBUILD_EXE_PATH=$(abspath $(TOP)/tools/xibuild/bin/Debug/xibuild.exe)
SYSTEM_XIBUILD=$(SYSTEM_MONO) $(XIBUILD_EXE_PATH) $(XIBUILD_VERBOSITY)

PKG_CONFIG=$(MONO_PREFIX)/bin/pkg-config

MAC_PRODUCT=Xamarin.Mac
MAC_PACKAGE_NAME=xamarin.mac
MAC_PACKAGE_NAME_LOWER=$(shell echo $(MAC_PACKAGE_NAME) | tr "[:upper:]" "[:lower:]")

MAC_PACKAGE_VERSION_MAJOR=$(word 1, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_MINOR=$(word 2, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_REV=$(word 3, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_BUILD=$(word 4, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_MAJOR_MINOR=$(MAC_PACKAGE_VERSION_MAJOR).$(MAC_PACKAGE_VERSION_MINOR)
MAC_PACKAGE_UPDATE_ID=$(shell echo $(subst ., ,$(MAC_PACKAGE_VERSION).$(MAC_PACKAGE_VERSION_BUILD)) | awk '{printf "2%02d%02d%02d%03d",$$1,$$2,$$3,$$4}')
MAC_PACKAGE_TITLE=Xamarin $(MAC_PACKAGE_NAME) $(MAC_PACKAGE_VERSION)

MACOS_NUGET=Microsoft.macOS
MACOS_NUGET_VERSION=$(MACOS_NUGET_OS_VERSION).$(MACOS_NUGET_COMMIT_DISTANCE)
MACOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(MACOS_NUGET_VERSION)))
MACOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(MACOS_NUGET_VERSION)))
MACOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(MACOS_NUGET_VERSION)))
MACOS_NUGET_VERSION_NO_METADATA=$(MACOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
MACOS_NUGET_VERSION_FULL=$(MACOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

ifneq ($(TESTS_USE_SYSTEM),)
MAC_DESTDIR ?= /
else
MAC_DESTDIR ?= $(TOP)/_mac-build
endif
MAC_TARGETDIR ?= $(MAC_DESTDIR)

# make sure we have full paths. The patsubst function is to remove any trailing slash (this may leave the variable empty)
override MAC_DESTDIR := $(patsubst %/,%,$(abspath $(MAC_DESTDIR)))
override MAC_TARGETDIR := $(patsubst %/,%,$(abspath $(MAC_TARGETDIR)))

MAC_FRAMEWORK_DIR = /Library/Frameworks/Xamarin.Mac.framework
MAC_FRAMEWORK_VERSIONED_DIR = $(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)
MAC_FRAMEWORK_CURRENT_DIR = $(MAC_FRAMEWORK_DIR)/Versions/$(MAC_INSTALL_VERSION)

MOBILE_BCL_DIR = $(MAC_DESTDIR)$(MAC_FRAMEWORK_CURRENT_DIR)/lib/mono/Xamarin.Mac
MAC_mobile_CSC = $(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MOBILE_BCL_DIR)/System.dll -r:$(MOBILE_BCL_DIR)/System.Core.dll -r:$(MOBILE_BCL_DIR)/System.Xml.dll -r:$(MOBILE_BCL_DIR)/mscorlib.dll -r:$(MOBILE_BCL_DIR)/System.Net.Http.dll -r:$(MOBILE_BCL_DIR)/Facades/System.Drawing.Common.dll -deterministic

FULL_BCL_DIR = $(MAC_DESTDIR)$(MAC_FRAMEWORK_CURRENT_DIR)/lib/mono/4.5
MAC_full_CSC = $(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(FULL_BCL_DIR)/System.dll -r:$(FULL_BCL_DIR)/System.Core.dll -r:$(FULL_BCL_DIR)/System.Xml.dll -r:$(FULL_BCL_DIR)/mscorlib.dll -r:$(FULL_BCL_DIR)/System.Net.Http.dll -r:$(FULL_BCL_DIR)/Facades/System.Drawing.Common.dll -deterministic

MAC_PACKAGE_FILENAME=$(MAC_PACKAGE_NAME_LOWER)-$(MAC_PACKAGE_VERSION).pkg
MAC_PACKAGE_DMG_FILENAME=$(MAC_PACKAGE_NAME_LOWER)-$(MAC_PACKAGE_VERSION).dmg
MAC_PACKAGE_DMG_DIRNAME="$(MAC_PACKAGE_TITLE)"
MAC_PACKAGE_UTI=com.$(MAC_PACKAGE_NAME_LOWER).pkg
MAC_PACKAGE_INSTALL_LOCATION=$(MAC_FRAMEWORK_VERSIONED_DIR)

TT = $(DOTNET) tool restore && $(DOTNET) t4

PRODUCT_KEY_PATH?=$(TOP)/product.snk

include $(TOP)/mk/quiet.mk

IOS_SOURCE=$(TOP)/src
IOS_BUILD_SOURCE=$(IOS_SOURCE)/build/ios/native
IOS_COMMON_BUILD_SOURCE=$(IOS_SOURCE)/build/common
MAC_SOURCE=$(TOP)/src
MAC_FULL_BUILD_SOURCE=$(MAC_SOURCE)/build/mac/full
MAC_MODERN_BUILD_SOURCE=$(MAC_SOURCE)/build/mac/mobile
MAC_COMMON_BUILD_SOURCE=$(MAC_SOURCE)/build/common

ifneq ($(BUILD_REVISION),)
IOS_CSC_FLAGS_XI=-pathmap:"$(abspath $(IOS_COMMON_BUILD_SOURCE))/=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_PACKAGE_VERSION)/src/Xamarin.iOS/" -pathmap:"$(abspath $(IOS_BUILD_SOURCE))/=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_PACKAGE_VERSION)/src/Xamarin.iOS/" -pathmap:"$(abspath $(IOS_SOURCE))/=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_PACKAGE_VERSION)/src/Xamarin.iOS/"
MAC_CSC_FLAGS_XM=-pathmap:"$(abspath $(MAC_COMMON_BUILD_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/" -pathmap:"$(abspath $(MAC_FULL_BUILD_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/" -pathmap:"$(abspath $(MAC_MODERN_BUILD_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/" -pathmap:"$(abspath $(MAC_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/"
endif

ifdef ENABLE_XAMARIN
-include $(MACCORE_PATH)/Make.config
endif

JENKINS_RESULTS_DIRECTORY ?= $(abspath $(TOP)/jenkins-results)

# Clone files instead of copying them on APFS file systems. Much faster.
CP:=$(shell df -t apfs / >/dev/null 2>&1 && echo "cp -c" || echo "cp")

# WORKAROUND, Ideally it should be xcode-$(XCODE_PRODUCT_BUILD_VERSION) but mono does not build binaries for each xcode release
# Xcode 12.4 Build 12D4e
XCODE_IOS_ARCHIVE_VERSION=xcode-12D4e
# Xcode 12.4 Build 12D4e
XCODE_MACOS_ARCHIVE_VERSION=xcode-12D4e
MONO_IOS_FILENAME:=ios-release-Darwin-$(MONO_HASH).7z
MONO_IOS_URL:=https://xamjenkinsartifact.azureedge.net/mono-sdks/$(XCODE_IOS_ARCHIVE_VERSION)/$(MONO_IOS_FILENAME)
MONO_MAC_FILENAME:=mac-release-Darwin-$(MONO_HASH).7z
MONO_MAC_URL:=https://xamjenkinsartifact.azureedge.net/mono-sdks/$(XCODE_MACOS_ARCHIVE_VERSION)/$(MONO_MAC_FILENAME)
MONO_MACCATALYST_FILENAME:=maccat-release-Darwin-$(MONO_HASH).7z
MONO_MACCATALYST_URL:=https://xamjenkinsartifact.azureedge.net/mono-sdks/$(XCODE_MACOS_ARCHIVE_VERSION)/$(MONO_MACCATALYST_FILENAME)

# Setup various variables depending on whether mono is downloaded or built from source
ifeq ($(MONO_BUILD_FROM_SOURCE),)
MONO_IOS_SDK_DESTDIR:=$(abspath $(TOP)/builds/downloads/$(basename $(MONO_IOS_FILENAME)))
MONO_MAC_SDK_DESTDIR:=$(abspath $(TOP)/builds/downloads/$(basename $(MONO_MAC_FILENAME)))
MONO_MACCATALYST_SDK_DESTDIR:=$(abspath $(TOP)/builds/downloads/$(basename $(MONO_MACCATALYST_FILENAME)))
MONO_BUILD_MODE=download-mono
else
MONO_IOS_SDK_DESTDIR:=$(abspath $(MONO_PATH)/sdks/out)
MONO_MAC_SDK_DESTDIR:=$(abspath $(MONO_PATH)/sdks/out)
MONO_MACCATALYST_SDK_DESTDIR:=$(abspath $(MONO_PATH)/sdks/out)
MONO_BUILD_MODE=compile-mono
endif

-include $(TOP)/dotnet.config
$(TOP)/dotnet.config: $(TOP)/eng/Versions.props
	$(Q) grep MicrosoftDotnetSdkInternalPackageVersion $(TOP)/eng/Versions.props | sed -e 's/<*\/*MicrosoftDotnetSdkInternalPackageVersion>//g' -e 's/[ \t]*/DOTNET_VERSION=/' >> $@.tmp
	$(Q) grep MicrosoftNETCoreAppRefPackageVersion $(TOP)/eng/Versions.props | sed -e 's/<*\/*MicrosoftNETCoreAppRefPackageVersion>//g' -e 's/[ \t]*/BUNDLED_NETCORE_PLATFORMS_PACKAGE_VERSION=/' >> $@.tmp
	$(Q) grep MicrosoftNETWorkloadEmscriptenManifest60100PackageVersion $(TOP)/eng/Versions.props | sed -e 's/<*\/*MicrosoftNETWorkloadEmscriptenManifest60100PackageVersion>//g' -e 's/[ \t]*/EMSCRIPTEN_MANIFEST_PACKAGE_VERSION=/' >> $@.tmp
	$(Q) mv $@.tmp $@

DOTNET_DESTDIR ?= $(TOP)/_build
DOTNET_NUPKG_DIR ?= $(DOTNET_DESTDIR)/nupkgs
DOTNET_PKG_DIR ?= $(DOTNET_DESTDIR)/pkgs

# Configuration for .NET 6.
# We're using preview versions, and there will probably be many of them, so install locally (into builds/downloads) if there's no system version to
# avoid consuming a lot of disk space (since they're never automatically deleted). The system-dependencies.sh script will install locally as long
# as there's a TARBALL url.

# If you build dotnet/runtime locally, "*-dev" is the version the built artifacts will use (and which we must reference)
CUSTOM_DOTNET_VERSION=6.0.0-dev

ifdef CUSTOM_DOTNET
DOTNET_BCL_VERSION=$(CUSTOM_DOTNET_VERSION)
export CUSTOM_DOTNET_VERSION
else
DOTNET_BCL_VERSION=$(BUNDLED_NETCORE_PLATFORMS_PACKAGE_VERSION)
endif

DOTNET_TFM=net6.0
DOTNET_VERSION_BAND=$(firstword $(subst -, ,$(DOTNET_VERSION)))
DOTNET_INSTALL_NAME=dotnet-sdk-$(DOTNET_VERSION)
DOTNET_DIR=$(abspath $(TOP)/builds/downloads/$(DOTNET_INSTALL_NAME))
DOTNET=$(DOTNET_DIR)/dotnet
DOTNET_BCL_DIR:=$(abspath $(TOP)/packages/microsoft.netcore.app.ref/$(DOTNET_BCL_VERSION)/ref/$(DOTNET_TFM))

# Use the System.Runtime.InteropServices.NFloat.Internal package to get the System.Runtime.InteropServices.dll reference assembly for
# .NET 6. This is no longer needed for .NET 7, when we can switch back to the usual BCL reference assemblies.
ifeq ($(DOTNET_TFM),net6.0)
DOTNET_SYSTEM_RUNTIME_INTEROPSERVICES_REF_ASSEMBLY_DIR:=$(abspath $(TOP)/packages/system.runtime.interopservices.nfloat.internal/6.0.1/ref/net6.0)
else
DOTNET_SYSTEM_RUNTIME_INTEROPSERVICES_REF_ASSEMBLY_DIR:=$(DOTNET_BCL_DIR)
endif

# The sdk version band has the last two digits set to 0: https://github.com/dotnet/sdk/blob/22c4860dcb2cf6b123dd641cc4a87a50380759d5/src/Resolvers/Microsoft.NET.Sdk.WorkloadManifestReader/SdkDirectoryWorkloadManifestProvider.cs#L52-L53
DOTNET_MANIFEST_VERSION_BAND=$(shell echo $(DOTNET_VERSION_BAND) | sed 's/..$$/00/')
# We must do the same for our version band: the last two digits must be set to 0.
MANIFEST_VERSION_BAND=6.0.400
# The toolchain can either be hardcoded to something like 6.0.200, or set to MANIFEST_VERSION_BAND.
# Typically it should be MANIFEST_VERSION_BAND, but it usually takes a while after MANIFEST_VERSION_BAND is bumped
# for this to follow suit, in which case we can keep things working by hardcoding the previous version band.
TOOLCHAIN_MANIFEST_VERSION_BAND=6.0.300

# The location of csc changes depending on whether we're using a preview or a stable/service release :/
DOTNET_CSC_PATH_PREVIEW=$(DOTNET_DIR)/sdk/$(DOTNET_VERSION)/Roslyn/bincore/csc.dll
DOTNET_CSC_PATH_STABLE=$(DOTNET_DIR)/sdk/$(DOTNET_VERSION_BAND)/Roslyn/bincore/csc.dll

# Attempt to detect where csc is based on the .NET version. This may fail in the future: feel free to fix/hardcode whatever's necessary to find csc.dll.
ifeq (rtm,$(findstring rtm,$(DOTNET_VERSION)))
DOTNET_CSC=$(DOTNET) exec $(DOTNET_CSC_PATH_STABLE)
else
ifeq (servicing,$(findstring servicing,$(DOTNET_VERSION)))
DOTNET_CSC=$(DOTNET) exec $(DOTNET_CSC_PATH_STABLE)
else
DOTNET_CSC=$(DOTNET) exec $(DOTNET_CSC_PATH_PREVIEW)
endif
endif

# How are our assemblies named?
DOTNET_IOS_ASSEMBLY_NAME=Microsoft.iOS
DOTNET_TVOS_ASSEMBLY_NAME=Microsoft.tvOS
DOTNET_MACCATALYST_ASSEMBLY_NAME=Microsoft.MacCatalyst
DOTNET_MACOS_ASSEMBLY_NAME=Microsoft.macOS

# This variable includes all the platforms we support, even those that might be disabled in this build.
ALL_PLATFORMS=iOS tvOS watchOS macOS
ALL_DOTNET_PLATFORMS=iOS macOS tvOS MacCatalyst

DOTNET_PLATFORMS=
ifdef INCLUDE_IOS
DOTNET_PLATFORMS+=iOS
ifdef INCLUDE_DEVICE
DOTNET_IOS_RUNTIME_IDENTIFIERS=ios-arm ios-arm64 iossimulator-x86 iossimulator-x64 iossimulator-arm64
DOTNET_IOS_RUNTIME_IDENTIFIERS_32=ios-arm iossimulator-x86
DOTNET_IOS_RUNTIME_IDENTIFIERS_64=ios-arm64 iossimulator-x64 iossimulator-arm64
else
DOTNET_IOS_RUNTIME_IDENTIFIERS=iossimulator-x86 iossimulator-x64 iossimulator-arm64
DOTNET_IOS_RUNTIME_IDENTIFIERS_32=iossimulator-x86
DOTNET_IOS_RUNTIME_IDENTIFIERS_64=iossimulator-x64 iossimulator-arm64
endif
endif

ifdef INCLUDE_TVOS
DOTNET_PLATFORMS+=tvOS
ifdef INCLUDE_DEVICE
DOTNET_TVOS_RUNTIME_IDENTIFIERS=tvos-arm64 tvossimulator-x64 tvossimulator-arm64
else
DOTNET_TVOS_RUNTIME_IDENTIFIERS=tvossimulator-x64 tvossimulator-arm64
endif
endif

ifdef INCLUDE_DOTNET_WATCHOS
DOTNET_PLATFORMS+=watchOS
ifdef INCLUDE_DEVICE
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS=watchos-arm watchos-x86
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS_32=watchos-arm watchos-x86
else
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS=watchos-x86 watchos-x64
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS_32=watchos-x86
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS_64=watchos-x64
endif
endif

ifdef INCLUDE_MACCATALYST
DOTNET_PLATFORMS+=MacCatalyst
DOTNET_MACCATALYST_RUNTIME_IDENTIFIERS=maccatalyst-x64 maccatalyst-arm64
endif

ifdef INCLUDE_MAC
DOTNET_PLATFORMS+=macOS
DOTNET_CORECLR_PLATFORMS+=macOS
DOTNET_MACOS_RUNTIME_IDENTIFIERS=osx-x64 osx-arm64
endif

ifdef INCLUDE_IOS
DOTNET_WINDOWS_PLATFORMS = iOS
endif

# Create variables prefixed with the correctly cased platform name from the upper-cased platform name. This simplifies code in a few areas (whenever we foreach over DOTNET_PLATFORMS).
$(foreach platform,$(DOTNET_PLATFORMS),$(eval DOTNET_$(platform)_RUNTIME_IDENTIFIERS:=$(DOTNET_$(shell echo $(platform) | tr a-z A-Z)_RUNTIME_IDENTIFIERS)))

# Create a variable with all the runtime identifiers
DOTNET_RUNTIME_IDENTIFIERS=$(foreach platform,$(DOTNET_PLATFORMS),$(DOTNET_$(platform)_RUNTIME_IDENTIFIERS))

# Create a variable with all the CoreCLR runtime identifiers
DOTNET_CORECLR_RUNTIME_IDENTIFIERS=$(foreach platform,$(DOTNET_CORECLR_PLATFORMS),$(DOTNET_$(platform)_RUNTIME_IDENTIFIERS))

# Create a variable with the platform in uppercase
DOTNET_PLATFORMS_UPPERCASE:=$(shell echo $(DOTNET_PLATFORMS) | tr a-z A-Z)

# All desktop platforms we're building for
DOTNET_DESKTOP_PLATFORMS:=$(filter macOS MacCatalyst,$(DOTNET_PLATFORMS))

# a few lookup tables, because the data we have is not always in the format we need it
DOTNET_iossimulator-x64_ARCHITECTURES=x86_64
DOTNET_iossimulator-arm64_ARCHITECTURES=arm64
DOTNET_iossimulator-x86_ARCHITECTURES=x86
DOTNET_ios-arm_ARCHITECTURES=armv7 armv7s
DOTNET_ios-arm64_ARCHITECTURES=arm64
DOTNET_tvossimulator-x64_ARCHITECTURES=x86_64
DOTNET_tvossimulator-arm64_ARCHITECTURES=arm64
DOTNET_tvos-arm64_ARCHITECTURES=arm64
DOTNET_osx-x64_ARCHITECTURES=x86_64
DOTNET_osx-arm64_ARCHITECTURES=arm64
DOTNET_maccatalyst-x64_ARCHITECTURES=x86_64
DOTNET_maccatalyst-arm64_ARCHITECTURES=arm64

DOTNET_iossimulator-x64_SDK_PLATFORM=iphonesimulator
DOTNET_iossimulator-arm64_SDK_PLATFORM=iphonesimulator
DOTNET_iossimulator-x86_SDK_PLATFORM=iphonesimulator
DOTNET_ios-arm_SDK_PLATFORM=iphoneos
DOTNET_ios-arm64_SDK_PLATFORM=iphoneos
DOTNET_tvossimulator-x64_SDK_PLATFORM=tvsimulator
DOTNET_tvossimulator-arm64_SDK_PLATFORM=tvsimulator
DOTNET_tvos-arm64_SDK_PLATFORM=tvos
DOTNET_osx-x64_SDK_PLATFORM=mac
DOTNET_osx-arm64_SDK_PLATFORM=mac
DOTNET_maccatalyst-x64_SDK_PLATFORM=maccatalyst
DOTNET_maccatalyst-arm64_SDK_PLATFORM=maccatalyst

DOTNET_iOS_SDK_PLATFORMS=iphonesimulator iphoneos
DOTNET_tvOS_SDK_PLATFORMS=tvsimulator tvos
DOTNET_macOS_SDK_PLATFORMS=mac
DOTNET_MacCatalyst_SDK_PLATFORMS=maccatalyst

# A local feed to place test nugets.
NUGET_TEST_FEED=$(abspath $(TOP)/tests/.nuget/packages)

.SUFFIXES:
MAKEFLAGS += --no-builtin-rules

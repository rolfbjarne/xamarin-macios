#!/bin/groovy

// global variables
repository = "xamarin/xamarin-macios"
isPr = (env.ghprbPullId && !env.ghprbPullId.empty ? true : false)
branchName = (isPr ? ("pr" + env.ghprbPullId) : env.BRANCH_NAME)
gitHash = null
packagePrefix = null
virtualPath = null
xiPackageUrl = null
xmPackageUrl = null
utils = null
errorMessage = null
currentStage = null

xiPackageFilename = null
xmPackageFilename = null
reportPrefix = null

def abortExecutingBuilds ()
{
    // This runs into problems with the Jenkins sandbox:
    //      org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException: Scripts not permitted to use method jenkins.model.Jenkins getItemByFullName java.lang.String
    // so disable for now.

    // def job = Jenkins.instance.getItemByFullName (env.JOB_NAME)
    // for (build in job.builds) {
    //     if (!build.isBuilding ())
    //         continue

    //     if (build.number > currentBuild.number) {
    //         error ("There is already a newer build in progress (#${build.number})")
    //     } else if (build.number < currentBuild.number) {
    //         def exec = build.getExecutor ()
    //         if (exec == null) {
    //             echo ("No executor for build ${build.number}")
    //         } else {
    //             exec.interrupt (Result.ABORTED, new CauseOfInterruption.UserInterruption ("Aborted by build #${currentBuild.number}"))
    //             echo ("Aborted previous build: #${build.number}")
    //         }
    //     }
    // }
}

def githubAddComment (url, markdown)
{
    def json = groovy.json.JsonOutput.toJson ([body: markdown])
    def jsonFile = "${workspace}/xamarin-macios/jenkins/commit-comments.json"
    try {
        writeFile (file: "${jsonFile}", text: "${json}")
        sh ("cat '${jsonFile}'")
        withCredentials ([string (credentialsId: 'macios_github_comment_token', variable: 'GITHUB_COMMENT_TOKEN')]) {
            sh ("curl -i -H 'Authorization: token ${GITHUB_COMMENT_TOKEN}' ${url} --data '@${jsonFile}'")
        }
    } finally {
        sh ("rm -f ${jsonFile}")
    }
}

def commentOnCommit (commitHash, markdown)
{
    githubAddComment ("https://api.github.com/repos/${repository}/commits/${commitHash}/comments", markdown)
}

def commentOnPullRequest (pullRequest, markdown)
{
    githubAddComment ("https://api.github.com/repos/${repository}/pulls/${pullRequest}/comments", markdown)
}

def addComment (markdown)
{
    if (isPr) {
        commentOnPullRequest ("${env.CHANGE_ID}", markdown)
    } else {
        commentOnCommit ("${gitHash}", markdown)
    }
}

def reportFinalStatus (err, gitHash, currentStage)
{
    def commentFile = "${workspace}/xamarin-macios/jenkins/pr-comments.md"
    def comment = null
    def status = currentBuild.currentResult

    if ("${status}" == "SUCCESS" && err == "") {
        comment = "âœ… [Jenkins job](${env.RUN_DISPLAY_URL}) succeeded"
    } else {
        comment = "ðŸ”¥ [Jenkins job](${env.RUN_DISPLAY_URL}) failed in stage '${currentStage}' ðŸ”¥"
        if (err != "")
            comment += " : ${err}"
        manager.addErrorBadge (comment)
        manager.buildFailure ()
    }

    if (fileExists (commentFile))
        comment += "\n\n" + readFile ("${commentFile}")

    addComment ("${comment}")
}

def processAtMonkeyWrench (outputFile)
{
    def tmpfile = "atmonkeywrench.tmp"
    try {
        sh (script: "grep '^@MonkeyWrench: ...Summary: ' '${outputFile}' > ${tmpfile}", returnStatus: true /* don't throw exceptions if something goes wrong */)
        def lines = readFile ("${tmpfile}").split ("\n")
        for (int i = 0; i < lines.length; i++) {
            def summary = lines [i].substring (27 /*"@MonkeyWrench: AddSummary: ".length*/).trim ()
            summary = summary.replace ("<br/>", "")
            summary = summary.replace ("<a href='", "")
            def href_end = summary.indexOf ("'>")
            if (href_end > 0)
                summary = summary.substring (0, href_end)
            echo (summary)
        }
    } finally {
        sh ("rm -f '${tmpfile}'")
    }
}

def uploadFiles (glob, virtualPath)
{
    step ([
        $class: 'WAStoragePublisher',
        allowAnonymousAccess: true,
        cleanUpContainer: false,
        cntPubAccess: true,
        containerName: "wrench",
        doNotFailIfArchivingReturnsNothing: false,
        doNotUploadIndividualFiles: false,
        doNotWaitForPreviousBuild: true,
        excludeFilesPath: '',
        filesPath: glob,
        storageAccName: 'bosstoragemirror',
        storageCredentialId: 'bc6a99d18d7d9ca3f6bf6b19e364d564',
        uploadArtifactsOnlyIfSuccessful: false,
        uploadZips: false,
        virtualPath: virtualPath
    ])
}

timestamps {
    node ('xamarin-macios && macos-high-sierra') {
        try {
            timeout (time: 9, unit: 'HOURS') {
                // This runs into problems with the Jenkins sandbox:
                // stage ("Checking for previous builds") {
                //     abortExecutingBuilds ()
                // }

                // Hard-code a workspace, since branch-based and PR-based
                // builds would otherwise use different workspaces, which
                // wastes a lot of disk space.
                workspace = "${env.HOME}/jenkins/workspace/xamarin-macios"
                withEnv ([
                    "PATH=/Library/Frameworks/Mono.framework/Versions/Current/Commands:${env.PATH}",
                    "WORKSPACE=${workspace}"
                    ]) {
                    sh ("mkdir -p '${workspace}/xamarin-macios'")
                    dir ("${workspace}") {
                        dir ("xamarin-macios") {
                            stage ('Checkout') {
                                currentStage = "${STAGE_NAME}"
                                echo ("Building on ${env.NODE_NAME}")
                                scmVars = checkout scm
                                gitHash = (isPr ? (env.ghprbActualCommit) : scmVars.GIT_COMMIT)
                            }
                        }

                        stage ('Provisioning') {
                            currentStage = "${STAGE_NAME}"
                            echo ("Building on ${env.NODE_NAME}")
                            sh ("${workspace}/xamarin-macios/jenkins/provision-deps.sh")
                        }

                        stage ('Build') {
                            currentStage = "${STAGE_NAME}"
                            echo ("Building on ${env.NODE_NAME}")
                            sh ("${workspace}/xamarin-macios/jenkins/build.sh --configure-flags --enable-xamarin")
                        }

                        stage ('Packaging') {
                            currentStage = "${STAGE_NAME}"
                            echo ("Building on ${env.NODE_NAME}")
                            sh ("${workspace}/xamarin-macios/jenkins/build-package.sh")
                            sh (script: "ls -la ${workspace}/package", returnStatus: true /* don't throw exceptions if something goes wrong */)
                        }
                    }

                    stage ('Signing') {
                        currentStage = "${STAGE_NAME}"
                        echo ("Building on ${env.NODE_NAME}")
                        def xiPackages = findFiles (glob: "package/xamarin.ios-*.pkg")
                        if (xiPackages.length > 0) {
                            xiPackageFilename = xiPackages [0].name
                            echo ("Created Xamarin.iOS package: ${xiPackageFilename}")
                        }
                        def xmPackages = findFiles (glob: "package/xamarin.mac-*.pkg")
                        if (xmPackages.length > 0) {
                            xmPackageFilename = xmPackages [0].name
                            echo ("Created Xamarin.Mac package: ${xmPackageFilename}")
                        }
                        withCredentials ([string(credentialsId: 'codesign_keychain_pw', variable: 'PRODUCTSIGN_KEYCHAIN_PASSWORD')]) {
                            sh ("${workspace}/xamarin-macios/jenkins/productsign.sh")
                        }
                    }

                    stage ('Upload to Azure') {
                        currentStage = "${STAGE_NAME}"
                        virtualPath = "jenkins/${branchName}/${gitHash}/${env.BUILD_NUMBER}"
                        packagePrefix = "https://bosstoragemirror.blob.core.windows.net/wrench/${virtualPath}/package"

                        // Create metadata.json and manifest
                        def uploadingFiles = findFiles (glob: "package/*")
                        def manifest = new StringBuilder ()
                        def metadata = new StringBuilder ()
                        metadata.append ("[\n")
                        for (int i = 0; i < uploadingFiles.length; i++) {
                            def file = uploadingFiles [i]
                            def f = new File (file)
                            def f_length = f.length ()
                            def md5 = sh (returnStdout: true, script: "md5 -q '${file}'").trim ()
                            manifest.append ("${packagePrefix}/${file}\n")
                            metadata.append ("  {\n    \"file\": \"${file}\",\n    \"md5\": \"${md5}\",\n    \"size\": ${f_length}\n  \"}")
                            if (i < uploadingFiles.length - 1)
                                metadata.append (",")
                            metadata.append ("\n")
                        }
                        metadata.append ("]\n")
                        writeFile (file: "package/manifest", text: manifest.toString ())
                        writeFile (file: "package/metadata.json", text: metadata.toString ())

                        sh ("ls -la package")
                        uploadFiles ("package/*", virtualPath)
                    }

                    stage ('Publish builds to GitHub') {
                        currentStage = "${STAGE_NAME}"
                        utils = load ("${workspace}/xamarin-macios/jenkins/utils.groovy")
                        if (xiPackageFilename != null) {
                            xiPackageUrl = "${packagePrefix}/${xiPackageFilename}"
                            utils.reportGitHubStatus (gitHash, 'jenkins-PKG-Xamarin.iOS', "${xiPackageUrl}", 'SUCCESS', "${xiPackageFilename}")
                        }
                        if (xmPackageFilename != null) {
                            xmPackageUrl = "${packagePrefix}/${xmPackageFilename}"
                            utils.reportGitHubStatus (gitHash, 'jenkins-PKG-Xamarin.Mac', "${xmPackageUrl}", 'SUCCESS', "${xmPackageFilename}")
                        }
                    }

                    dir ('xamarin-macios') {
                        stage ('Launch external tests') {
                            currentStage = "${STAGE_NAME}"
                            if (isPr) {
                                echo "Currently not launching external tests for pull requests"
                            } else {
                                def outputFile = "${workspace}/xamarin-macios/wrench-launch-external.output.tmp"
                                try {
                                    withCredentials ([string(credentialsId: 'macios_provisionator_pat', variable: 'PROVISIONATOR_VSTS_PAT')]) {
                                        sh ("make -C ${workspace}/xamarin-macios/tests wrench-launch-external MAC_PACKAGE_URL=${xmPackageUrl} IOS_PACKAGE_URL=${xiPackageUrl} WRENCH_URL=${env.RUN_DISPLAY_URL} BUILD_REVISION=${gitHash} BUILD_LANE=jenkins/${branchName} BUILD_WORK_HOST=${env.NODE_NAME} 2>&1 | tee ${outputFile}")
                                    }
                                    processAtMonkeyWrench (outputFile)
                                } catch (error) {
                                    echo ("ðŸš« Launching external tests failed: ${error} ðŸš«")
                                    manager.addWarningBadge ("Failed to launch external tests")
                                } finally {
                                    sh ("rm -f '${outputFile}'")
                                }
                            }
                        }

                        stage ('Install Provisioning Profiles') {
                            currentStage = "${STAGE_NAME}"
                            sh ("${workspace}/maccore/tools/install-qa-provisioning-profiles.sh")
                        }

                        stage ('Publish reports') {
                            currentStage = "${STAGE_NAME}"
                            reportPrefix = sh (script: "${workspace}/xamarin-macios/jenkins/publish-results.sh | grep '^Url Prefix: ' | sed 's/^Url Prefix: //'", returnStdout: true).trim ()
                            echo ("Html report: ${reportPrefix}/tests/index.html")
                            echo ("API diff (from stable): ${reportPrefix}/api-diff/index.html")
                            echo ("API diff (from previous commit / before pull request): ${reportPrefix}/apicomparison/api-diff.html")
                            echo ("Generator diff: ${reportPrefix}/generator-diff/index.html")
                        }

                        stage ('API diff') {
                            currentStage = "${STAGE_NAME}"
                            def apidiffResult = sh (script: "${workspace}/xamarin-macios/jenkins/build-api-diff.sh", returnStatus: true)
                            if (apidiffResult != 0)
                                manager.addWarningBadge ("Failed to generate API diff")
                            echo ("API diff (from stable): ${reportPrefix}/api-diff/index.html")
                        }

                        stage ('API & Generator comparison') {
                            currentStage = "${STAGE_NAME}"
                            def compareResult = sh (script: "${workspace}/xamarin-macios/jenkins/compare.sh", returnStatus: true)
                            if (compareResult != 0)
                                manager.addWarningBadge ("Failed to generate API / Generator diff")
                            echo ("API diff (from previous commit / before pull request): ${reportPrefix}/apicomparison/api-diff.html")
                            echo ("Generator diff: ${reportPrefix}/generator-diff/index.html")
                        }

                        timeout (time: 6, unit: 'HOURS') {
                            stage ('Run tests') {
                                currentStage = "Test run"
                                echo ("Building on ${env.NODE_NAME}")
                                if (isPr) {
                                    echo "Not running tests here because they're run on public Jenkins."
                                } else {
                                    echo ("Html report: ${reportPrefix}/tests/index.html")
                                    sh ("${workspace}/xamarin-macios/jenkins/run-tests.sh --target=wrench-jenkins")
                                }
                            }

                            stage ('Test docs') {
                                currentStage = "${STAGE_NAME}"
                                echo ("Building on ${env.NODE_NAME}")
                                sh ("make -C ${workspace}/xamarin-macios/tests wrench-docs")
                            }
                        }

                        stage ('Package Xamarin.Mac tests') {
                            sh ("make -C ${workspace}/xamarin-macios/tests package-tests")
                            uploadFiles ("xamarin-macios/tests/*.zip", virtualPath)
                        }
                    }
                }
                reportFinalStatus ("", "${gitHash}", "${currentStage}")
            } // timeout
        } catch (err) {
            reportFinalStatus ("${err}", "${gitHash}", "${currentStage}")
        } finally {
            stage ('Final report upload') {
                sh (script: "${workspace}/xamarin-macios/jenkins/publish-results.sh", returnStatus: true /* don't throw exceptions if something goes wrong */)
            }
            stage ('Cleanup') {
                sh (script: "make git-clean-all -C ${workspace}/xamarin-macios", returnStatus: true /* don't throw exceptions if something goes wrong */)
            }
        }
    } // node
} // timestamps

<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

	<PropertyGroup>
		<!-- Set to true when using the Microsoft.<platform>.Sdk NuGet. This is used by pre-existing/shared targets to tweak behavior depending on build system -->
		<_UsingXamarinSdk>true</_UsingXamarinSdk>
		<!-- This is the location of the Microsoft.<platform>.Sdk NuGet (/usr/local/share/dotnet/sdk/<version>/Sdks/Microsoft.[iOS/tvOS/watchOS/macOS].Sdk) -->
		<_XamarinSdkRootDirectory>$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)', '..'))\</_XamarinSdkRootDirectory>

		<_XamarinTaskAssembly Condition="'$(_PlatformName)' != 'macOS'">$(_XamarinSdkRootDirectory)\tools\msbuild\iOS\Xamarin.iOS.Tasks.dll</_XamarinTaskAssembly>
		<_XamarinTaskAssembly Condition="'$(_PlatformName)' == 'macOS'">$(_XamarinSdkRootDirectory)\tools\msbuild\macOS\Xamarin.Mac.Tasks.dll</_XamarinTaskAssembly>
	</PropertyGroup>

	<!-- Version information -->
	<Import Project="Xamarin.Shared.Sdk.Versions.targets" />

	<!-- This contains the OS versions we support for target platform -->
	<Import Project="Microsoft.$(_PlatformName).Sdk.SupportedTargetPlatforms.targets" />

	<UsingTask TaskName="Xamarin.MacDev.Tasks.CompileNativeCode" AssemblyFile="$(_XamarinTaskAssembly)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.LinkNativeCode" AssemblyFile="$(_XamarinTaskAssembly)" />

	<!-- Project types and how do we distinguish between them

									  OutputType   Custom variable
		==================================================================
		iOS Executable Project        Exe
		iOS App Extension Project     Library      IsAppExtension
		iOS Binding Project           Library      IsBindingProject
		iOS Class Library Project     Library

		tvOS Executable Project       Exe
		tvOS App Extension Project    Library      IsAppExtension
		tvOS Binding Project          Library      IsBindingProject
		tvOS Class Library Project    Library

		watchOS App Project           Library      IsWatchOSApp
		watchOS App Extension Project Library      IsAppExtension
		watchOS Binding Project       Library      IsBindingProject
		watchOS Class Library Project Library

		macOS Executable Project        Exe
		macOS App Extension Project     Library      IsAppExtension
		macOS Binding Project           Library      IsBindingProject
		macOS Class Library Project     Library

	-->

	<PropertyGroup>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Exe'">iOSExecutableProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Library' And '$(IsAppExtension)' != ''">iOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Library' And '$(IsBindingProject)' != ''">iOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Library'">iOSClassLibrary</_ProjectType>

		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Exe'">tvOSExecutableProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Library' And '$(IsAppExtension)' != ''">tvOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Library' And '$(IsBindingProject)' != ''">tvOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Library'">tvOSClassLibrary</_ProjectType>

		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS' And '$(IsWatchOSApp)' != ''">watchOSAppProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS' And '$(IsAppExtension)' != ''">watchOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS' And '$(IsBindingProject)' != ''">watchOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS'">watchOSClassLibrary</_ProjectType>

		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Exe'">macOSExecutableProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Library' And '$(IsAppExtension)' != ''">macOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Library' And '$(IsBindingProject)' != ''">macOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Library'">macOSClassLibrary</_ProjectType>
	</PropertyGroup>

	<!-- Automatically supply project capabilities for IDE use -->
	<ItemGroup>
		<ProjectCapability Include="Apple" />
		<ProjectCapability Include="Mobile" />
		
		<ProjectCapability Include="IOSApplication" Condition="'$(_ProjectType)' == 'iOSExecutableProject'" />
		<ProjectCapability Include="IOSAppExtension" Condition="'$(_ProjectType)' == 'iOSAppExtensionProject'" />
		<ProjectCapability Include="IOSBinding" Condition="'$(_ProjectType)' == 'iOSBindingProject'" />
		<ProjectCapability Include="IOSClassLibrary" Condition="'$(_ProjectType)' == 'iOSClassLibrary'" />
		<ProjectCapability Include="TvOSApplication" Condition="'$(_ProjectType)' == 'tvOSExecutableProject'" />
		<ProjectCapability Include="TvOSAppExtension" Condition="'$(_ProjectType)' == 'tvOSAppExtensionProject'" />
		<ProjectCapability Include="TvOSBinding" Condition="'$(_ProjectType)' == 'tvOSBindingProject'" />
		<ProjectCapability Include="TvOSClassLibrary" Condition="'$(_ProjectType)' == 'tvOSClassLibrary'" />
		<ProjectCapability Include="WatchOSApplication" Condition="'$(_ProjectType)' == 'watchOSAppProject'" />
		<ProjectCapability Include="WatchOSAppExtension" Condition="'$(_ProjectType)' == 'watchOSAppExtensionProject'" />
		<ProjectCapability Include="WatchOSBinding" Condition="'$(_ProjectType)' == 'watchOSBindingProject'" />
		<ProjectCapability Include="WatchOSClassLibrary" Condition="'$(_ProjectType)' == 'watchOSClassLibrary'" />
		<ProjectCapability Include="MacOSApplication" Condition="'$(_ProjectType)' == 'macOSExecutableProject'" />
		<ProjectCapability Include="MacOSAppExtension" Condition="'$(_ProjectType)' == 'macOSAppExtensionProject'" />
		<ProjectCapability Include="MacOSBinding" Condition="'$(_ProjectType)' == 'macOSBindingProject'" />
		<ProjectCapability Include="MacOSClassLibrary" Condition="'$(_ProjectType)' == 'macOSClassLibrary'" />

		<!-- See https://work.azdo.io/1112733 -->
		<!-- Conflicts with our targets generator in VS+CPS -->
		<ProjectCapability Remove="LaunchProfiles" />
	</ItemGroup>
	
	<PropertyGroup>
		<!-- We must run the linker for executable projects and app extension projects. We must set PublishTrimmed before importing Microsoft.NET.Sdk, because it'll be evaluated there. -->
		<PublishTrimmed Condition="'$(PublishTrimmed)' == '' And ($(_ProjectType.EndsWith ('ExecutableProject')) Or $(_ProjectType.EndsWith ('AppExtensionProject')))">true</PublishTrimmed>

		<!-- App extensions are self-contained, even though their OutputType=Library -->
		<SelfContained Condition="'$(SelfContained)' == '' And $(_ProjectType.EndsWith ('AppExtensionProject'))">true</SelfContained>

		<!-- Add a property that specifies the name of the platform assembly for each platform -->
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'iOS' ">Xamarin.iOS</_PlatformAssemblyName>
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'tvOS' ">Xamarin.TVOS</_PlatformAssemblyName>
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'watchOS' ">Xamarin.WatchOS</_PlatformAssemblyName>
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'macOS' ">Xamarin.Mac</_PlatformAssemblyName>

		<!-- We have to set DebuggerSupport before importing Microsoft.NET.Sdk -->
		<!-- That means we have to set _BundlerDebug before that, because DebuggerSupport depends on it -->
		<!-- Xamarin.Mac: use MmpDebug (this differs from the old-style logic, which checks $(DebugSymbols) as well) -->
		<_BundlerDebug Condition="'$(_BundlerDebug)' == '' And '$(_PlatformName)' == 'macOS'">$(MmpDebug)</_BundlerDebug>
		<!-- Xamarin.iOS: Use MtouchDebug -->
		<_BundlerDebug Condition="'$(_BundlerDebug)' == '' And '$(_PlatformName)' != 'macOS'">$(MtouchDebug)</_BundlerDebug>
		<!-- Otherwise the default is true if we're building a Debug configuration -->
		<_BundlerDebug Condition="'$(_BundlerDebug)' == '' And '$(Configuration)' == 'Debug'">true</_BundlerDebug>
		<!-- As a last resort, the default is false for all platforms -->
		<_BundlerDebug Condition="'$(_BundlerDebug)' == ''">false</_BundlerDebug>

		<!-- On the other hand, we want the linker to link away debug support in the actual code unless we're building for Debug -->
		<DebuggerSupport Condition="'$(DebuggerSupport)' == ''">$(_BundlerDebug)</DebuggerSupport>
	</PropertyGroup>

	<PropertyGroup>
		<TargetPlatformSupported Condition=" '$(TargetPlatformIdentifier)' == '$(_PlatformName)' ">true</TargetPlatformSupported>
	</PropertyGroup>

	<!-- Default item includes (globs and implicit references) -->
	<Import Project="Xamarin.Shared.Sdk.DefaultItems.targets" />
	<Import Project="Xamarin.Shared.Sdk.TargetFrameworkInference.targets" />

	<!-- Inject our custom logic into *DependsOn variables -->
	<PropertyGroup>
		<BuildDependsOn>
			BuildOnlySettings;
			_CollectBundleResources;
			_PackLibraryResources;
			_UnpackLibraryResources;
			$(BuildDependsOn);
			_CreateAppBundle;
			Codesign;
		</BuildDependsOn>

		<!-- We re-use ComputeFilesToPublish & CopyFilesToPublishDirectory to copy files to the .app -->
		<!-- ComputeFilesToPublish will run ILLink -->
		<CreateAppBundleDependsOn>
			_DetectAppManifest;
			_CopyResourcesToBundle;
			_CompileEntitlements;
			_CompileAppManifest;
			_ComputeLinkerArguments;
			ComputeFilesToPublish;
			_LoadLinkerOutput;
			_CompileNativeExecutable;
			_LinkNativeExecutable;
			_ComputePublishLocation;
			CopyFilesToPublishDirectory;
		</CreateAppBundleDependsOn>
	</PropertyGroup>

	<!-- Linker -->
	<PropertyGroup>
		<_AdditionalTaskAssemblyDirectory>$(_XamarinSdkRootDirectory)tools/dotnet-linker/</_AdditionalTaskAssemblyDirectory>
		<_AdditionalTaskAssembly>$(_AdditionalTaskAssemblyDirectory)dotnet-linker.dll</_AdditionalTaskAssembly>
	</PropertyGroup>
	<Target Name="_ComputeLinkerArguments" DependsOnTargets="_ComputeLinkMode;_ComputeFrameworkVariables;_ComputeFrameworkAssemblies;ComputeResolvedFilesToPublishList;_ParseBundlerArguments;">
		<!-- Validate the linker mode -->
		<Error Text="Invalid link mode: '$(_LinkMode)'. Valid link modes are: 'None', 'SdkOnly' and 'Full'" Condition="'$(_LinkMode)' != 'None' And '$(_LinkMode)' != 'SdkOnly' And '$(_LinkMode)' != 'Full'" />

		<PropertyGroup>
			<!-- Pass the custom options to our custom steps -->
			<_CustomLinkerOptionsFile>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)custom-linker-options.txt'))</_CustomLinkerOptionsFile>

			<!-- The directory where the linker puts *.items files that will be loaded in the _LoadLinkerOutput target -->
			<_LinkerItemsDirectory>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)linker-items'))</_LinkerItemsDirectory>

			<!-- A temporary output directory for our linker steps -->
			<_LinkerCacheDirectory>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)linker-cache'))</_LinkerCacheDirectory>

			<_CustomLinkerOptions>
				AssemblyName=$(AssemblyName).dll
				CacheDirectory=$(_LinkerCacheDirectory)
				Debug=$(_BundlerDebug)
				DeploymentTarget=$(_MinimumOSVersion)
				@(_XamarinFrameworkAssemblies -> 'FrameworkAssembly=%(Filename)')
				ItemsDirectory=$(_LinkerItemsDirectory)
				IsSimulatorBuild=$(_SdkIsSimulator)
				LinkMode=$(_LinkMode)
				MarshalManagedExceptionMode=$(_MarshalManagedExceptionMode)
				MarshalObjectiveCExceptionMode=$(_MarshalObjectiveCExceptionMode)
				Optimize=$(_BundlerOptimize)
				PartialStaticRegistrarLibrary=$(_LibPartialStaticRegistrar)
				Platform=$(_PlatformName)
				PlatformAssembly=$(_PlatformAssemblyName).dll
				Registrar=$(_BundlerRegistrar)
				SdkVersion=$(_SdkVersion)
				TargetArchitectures=$(TargetArchitectures)
				TargetFramework=$(_ComputedTargetFrameworkMoniker)
				Verbosity=$(_BundlerVerbosity)
			</_CustomLinkerOptions>
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --custom-data "LinkerOptionsFile=$(_CustomLinkerOptionsFile)"</_ExtraTrimmerArgs>

			<!-- Work around a linker issue: https://github.com/mono/linker/issues/1304 -->
			<!-- System.Runtime.dll isn't always copied to the .app -->
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) -p copy "System.Runtime"</_ExtraTrimmerArgs>

			<!-- TrimMode specifies what the linker will do with framework assemblies -->
			<TrimMode Condition="'$(_LinkMode)' == 'None'">copy</TrimMode> <!-- Don't use 'copyused', because that might still end up saving some assemblies, and if that's the platform assembly, it may break the partial static registrar -->
			<TrimMode Condition="'$(_LinkMode)' == 'SdkOnly' Or '$(_LinkMode)' == 'Full'">link</TrimMode>
			<!-- For Full link mode we also need to set TrimMode for all non-framework assemblies. This is done further below -->

			<!-- Verbose output, so that we get something to stdout when something goes wrong -->
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --verbose</_ExtraTrimmerArgs>

			<!--
				Always process symbols files, even in release mode, because
				the AOT compiler uses the symbol files to create DWARF debug
				information.

				FIXME: At some point we should set the DebuggerSupport
				property so that the linker can remove debugging support when
				in release mode, but the linker doesn't seem quite ready for
				this yet (ref: https://github.com/dotnet/sdk/pull/12144).
			-->
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) -b</_ExtraTrimmerArgs>

			<!-- We always want the linker to process debug symbols, even when building in Release mode, because the AOT compiler uses the managed debug symbols to output DWARF debugging symbols -->
			<TrimmerRemoveSymbols Condition="'$(TrimmerRemoveSymbols)' == ''">false</TrimmerRemoveSymbols>
		</PropertyGroup>

		<ItemGroup>
			<!-- Mark all assemblies to be linked if we're linking all assemblies -->
			<ResolvedFileToPublish
				Update="@(ResolvedFileToPublish)"
				Condition="'$(_LinkMode)' == 'Full' And '%(ResolvedFileToPublish.Extension)' == '.dll' And '%(ResolvedFileToPublish.AssetType)' != 'native'"
			>
				<TrimMode>link</TrimMode>
			</ResolvedFileToPublish>

			<!-- Mark our entry assembly as a root assembly. -->
			<TrimmerRootAssembly Include="$(AssemblyName)" />

			<!-- add a custom step which inserts any other steps we need -->
			<_TrimmerCustomSteps Include="$(_AdditionalTaskAssembly)">
				<BeforeStep>LoadReferencesStep</BeforeStep>
				<Type>Xamarin.SetupStep</Type>
			</_TrimmerCustomSteps>

			<TrimmerRootDescriptor Include="@(_BundlerXmlDefinitions)" />
		</ItemGroup>

		<!-- Create the file with our custom linker options -->
		<WriteLinesToFile File="$(_CustomLinkerOptionsFile)" Lines="$(_CustomLinkerOptions)" Overwrite="true" />
	</Target>

	<Target Name="_LoadLinkerOutput">
		<!-- Load _MainFile -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_MainFile.items" Condition="Exists('$(_LinkerItemsDirectory)/_MainFile.items')">
			<Output TaskParameter="Items" ItemName="_MainFile" />
		</ReadItemsFromFile>
		<!-- Load _MainLinkWith -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_MainLinkWith.items" Condition="Exists('$(_LinkerItemsDirectory)/_MainLinkWith.items')">
			<Output TaskParameter="Items" ItemName="_MainLinkWith" />
		</ReadItemsFromFile>
		<!-- Load _LinkerFrameworks -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_LinkerFrameworks.items" Condition="Exists('$(_LinkerItemsDirectory)/_LinkerFrameworks.items')">
			<Output TaskParameter="Items" ItemName="_LinkerFrameworks" />
		</ReadItemsFromFile>
		<!-- Load _BindingLibraryLinkWith -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_BindingLibraryLinkWith.items" Condition="Exists('$(_LinkerItemsDirectory)/_BindingLibraryLinkWith.items')">
			<Output TaskParameter="Items" ItemName="_BindingLibraryLinkWith" />
		</ReadItemsFromFile>
		<!-- Load _BindingLibraryLinkerFlags -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_BindingLibraryLinkerFlags.items" Condition="Exists('$(_LinkerItemsDirectory)/_BindingLibraryLinkerFlags.items')">
			<Output TaskParameter="Items" ItemName="_BindingLibraryLinkerFlags" />
		</ReadItemsFromFile>
		<!-- Load _BindingLibraryFrameworks -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_BindingLibraryFrameworks.items" Condition="Exists('$(_LinkerItemsDirectory)/_BindingLibraryFrameworks.items')">
			<Output TaskParameter="Items" ItemName="_BindingLibraryFrameworks" />
		</ReadItemsFromFile>
		<!-- Load _RegistrarFile -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_RegistrarFile.items" Condition="Exists('$(_LinkerItemsDirectory)/_RegistrarFile.items')">
			<Output TaskParameter="Items" ItemName="_RegistrarFile" />
		</ReadItemsFromFile>
	</Target>

	<!-- Native code -->

	<Target Name="_ComputeFrameworkVariables" DependsOnTargets="ResolveRuntimePackAssets">
		<ItemGroup>
			<!-- Look in the ResolvedFrameworkReference for our Microsoft.* package. This should only find a single package. -->
			<_XamarinFrameworkReference Include="@(ResolvedFrameworkReference)" Condition="'%(ResolvedFrameworkReference.Identity)' == 'Microsoft.$(_PlatformName)'" />
		</ItemGroup>
		<PropertyGroup>
			<_XamarinSdkRuntimePackDirectory>%(_XamarinFrameworkReference.RuntimePackPath)</_XamarinSdkRuntimePackDirectory>
			<_XamarinRefPackageDirectory>%(_XamarinFrameworkReference.TargetingPackPath)</_XamarinRefPackageDirectory>
			<_XamarinNativeLibraryDirectory>$(_XamarinSdkRuntimePackDirectory)/runtimes/$(RuntimeIdentifier)/native</_XamarinNativeLibraryDirectory>
			<_XamarinIncludeDirectory>$(_XamarinSdkRuntimePackDirectory)/runtimes/$(RuntimeIdentifier)/native</_XamarinIncludeDirectory>
			<_XamarinRefAssemblyDirectory>$(_XamarinRefPackageDirectory)/ref/net5.0/</_XamarinRefAssemblyDirectory>
			<_XamarinRefAssemblyPath>$(_XamarinRefAssemblyDirectory)$(_PlatformAssemblyName).dll</_XamarinRefAssemblyPath>

			<_LibPartialStaticRegistrar>$(_XamarinNativeLibraryDirectory)/Microsoft.$(_PlatformName).registrar.a</_LibPartialStaticRegistrar>
		</PropertyGroup>
	</Target>

	<Target Name="_ComputeFrameworkAssemblies" DependsOnTargets="_ComputeVariables;ComputeResolvedFilesToPublishList">
		<ItemGroup>
			<!-- Define 'framework assembly' or 'sdk assembly' as assemblies that comes from the .NET BCL NuGet -->
			<_XamarinFrameworkAssemblies Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.Extension)' == '.dll' And '%(ResolvedFileToPublish.NuGetPackageId)' == '$(_MonoNugetPackageId)'" />
		</ItemGroup>
	</Target>

	<Target Name="_ComputeVariables" DependsOnTargets="_GenerateBundleName;_ComputeFrameworkVariables;ComputeResolvedFilesToPublishList">
		<PropertyGroup>
			<_IntermediateNativeLibraryDir>$(IntermediateOutputPath)nativelibraries/</_IntermediateNativeLibraryDir>
			<_NativeExecutableName>$(_AppBundleName)</_NativeExecutableName>

			<_LibMonoLinkMode Condition="'$(_LibMonoLinkMode)' == '' And ('$(ComputedPlatform)' != 'iPhone' Or '$(_PlatformName)' == 'macOS')">dylib</_LibMonoLinkMode>
			<_LibMonoLinkMode Condition="'$(_LibMonoLinkMode)' == ''">static</_LibMonoLinkMode>
			<_LibMonoExtension Condition="'$(_LibMonoLinkMode)' == 'dylib'">dylib</_LibMonoExtension>
			<_LibMonoExtension Condition="'$(_LibMonoLinkMode)' == 'static'">a</_LibMonoExtension>

			<_LibXamarinLinkMode Condition="'$(_LibXamarinLinkMode)' == '' And '$(ComputedPlatform)' != 'iPhone' And '$(_PlatformName)' != 'macOS'">dylib</_LibXamarinLinkMode>
			<_LibXamarinLinkMode Condition="'$(_LibXamarinLinkMode)' == ''">static</_LibXamarinLinkMode>
			<_LibXamarinExtension Condition="'$(_LibXamarinLinkMode)' == 'dylib'">dylib</_LibXamarinExtension>
			<_LibXamarinExtension Condition="'$(_LibXamarinLinkMode)' == 'static'">a</_LibXamarinExtension>
			<_LibXamarinName Condition="'$(_LibXamarinName)' == '' And '$(_BundlerDebug)' == 'true'">libxamarin-debug.$(_LibXamarinExtension)</_LibXamarinName>
			<_LibXamarinName Condition="'$(_LibXamarinName)' == '' And '$(_BundlerDebug)' != 'true'">libxamarin.$(_LibXamarinExtension)</_LibXamarinName>

			<_MonoNugetPackageId Condition="'$(_PlatformName)' != 'macOS'">Microsoft.NETCore.App.Runtime.$(RuntimeIdentifier)</_MonoNugetPackageId>
			<_MonoNugetPackageId Condition="'$(_PlatformName)' == 'macOS'">Microsoft.NETCore.App.Runtime.Mono.$(RuntimeIdentifier)</_MonoNugetPackageId>
		</PropertyGroup>

		<ItemGroup>
			<!-- Select the native libraries from mono we need to link with and potentially copy into the app -->
			<_MonoLibrary
				Include="@(ResolvedFileToPublish)"
				Condition=" '%(ResolvedFileToPublish.AssetType)' == 'native' And
							'%(ResolvedFileToPublish.RuntimeIdentifier)' == '$(RuntimeIdentifier)' And
							'%(ResolvedFileToPublish.Extension)' == '.$(_LibMonoExtension)' And
							'%(ResolvedFileToPublish.NuGetPackageId)' == '$(_MonoNugetPackageId)'
							"
			/>
		</ItemGroup>
	</Target>

	<PropertyGroup>
		<_GenerateBindingsDependsOn>
			_ComputeBindingVariables;
			$(_GenerateBindingsDependsOn);
		</_GenerateBindingsDependsOn>
	</PropertyGroup>

	<Target Name="_ComputeBindingVariables" DependsOnTargets="_ComputeFrameworkVariables" Condition="'$(IsBindingProject)' == 'true'">
		<PropertyGroup>
			<BTouchToolExe>bgen.dll</BTouchToolExe>
			<BTouchToolPath>$(_XamarinSdkRootDirectory)\tools\lib\bgen</BTouchToolPath>
			<BaseLibDllPath>$(_XamarinRefAssemblyPath)</BaseLibDllPath>
			<_GeneratorAttributeAssembly>$(_XamarinSdkRootDirectory)/tools/lib/Xamarin.Apple.BindingAttributes.dll</_GeneratorAttributeAssembly>
		</PropertyGroup>
	</Target>

	<Target Name="_ComputeNativeExecutableInputs" DependsOnTargets="_ComputeVariables">
		<ItemGroup>
			<_CompileNativeExecutableFile Include="@(_MainFile)">
				<OutputFile>$(_IntermediateNativeLibraryDir)%(Filename).o</OutputFile>
			</_CompileNativeExecutableFile>
			<_CompileNativeExecutableFile Include="@(_RegistrarFile)">
				<OutputFile>$(_IntermediateNativeLibraryDir)%(Filename).o</OutputFile>
			</_CompileNativeExecutableFile>
			<_XamarinMainIncludeDirectory Include="$(_XamarinIncludeDirectory)" />
		</ItemGroup>
	</Target>

	<Target Name="_CompileNativeExecutable"
		DependsOnTargets="_DetectSdkLocations;_ComputeTargetArchitectures;_GenerateBundleName;_GetMinimumOSVersion;_ComputeNativeExecutableInputs"
		Inputs="@(_CompileNativeExecutableFile)"
		Outputs="@(_CompileNativeExecutableFile -> '%(OutputFile)')"
		>

		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_IntermediateNativeLibraryDir)" />

		<CompileNativeCode
			SessionId="$(BuildSessionId)"
			CompileInfo="@(_CompileNativeExecutableFile)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			IncludeDirectories="@(_XamarinMainIncludeDirectory)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkRoot="$(_SdkRoot)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		>
			<Output TaskParameter="ObjectFiles" ItemName="_NativeExecutableObjectFiles" />
		</CompileNativeCode>
	</Target>


	<!-- The .dylibs shipped with mono comes with the original identity:

	$ otool -l ~/.nuget/packages/microsoft.netcore.app.runtime.ios-x64/5.0.0-*/runtimes/ios-x64/native/libSystem.IO.Compression.Native.dylib | grep LC_ID_DYLIB -A 2
          cmd LC_ID_DYLIB
      cmdsize 184
         name /Users/runner/runners/2.165.2/work/1/s/artifacts/obj/native/netcoreapp5.0-iOS-Release-x64/System.IO.Compression.Native/libSystem.IO.Compression.Native.dylib (offset 24)

	This doesn't work after linking with these libraries, so this must be fixed to be @executable_path/. Eventually mono will ship dylibs we don't have to fix (https://github.com/dotnet/runtime/issues/34637).
	-->
	<Target Name="_UpdateDynamicLibraryId" DependsOnTargets="_ComputeVariables;_ParseBundlerArguments" Inputs="@(_MonoLibrary)" Outputs="@(_MonoLibrary -> '$(_IntermediateNativeLibraryDir)%(Filename)%(Extension)')" Condition=" '$(_PlatformName)' != 'macOS' ">
		<PropertyGroup>
			<_ExecutablePathPrefix Condition="'$(_PlatformName)' != 'macOS'">@executable_path/</_ExecutablePathPrefix>
			<_ExecutablePathPrefix Condition="'$(_PlatformName)' == 'macOS'">@executable_path/../$(_CustomBundleName)/</_ExecutablePathPrefix>
		</PropertyGroup>

		<!-- install_name_tool modifies the file in-place, so copy it first to a temporary directory before we fix it -->
		<Copy SourceFiles="%(_MonoLibrary.FullPath)" DestinationFolder="$(_IntermediateNativeLibraryDir)" />
		<Exec Command="xcrun install_name_tool -id $(_ExecutablePathPrefix)%(_MonoLibrary.Filename)%(_MonoLibrary.Extension) $(_IntermediateNativeLibraryDir)%(_MonoLibrary.Filename)%(_MonoLibrary.Extension)" EnvironmentVariables="DEVELOPER_DIR=$(_SdkDevPath)" />

		<!-- Update our item groups -->
		<ItemGroup>
			<_MonoLibraryFixed Include="@(_MonoLibrary -> '$(_IntermediateNativeLibraryDir)%(Filename)%(Extension)')" />
			<ResolvedFileToPublish Remove="@(_MonoLibrary)" />
			<ResolvedFileToPublish Include="@(_MonoLibraryFixed)" />
			<_MonoLibrary Remove="@(_MonoLibrary)" />
			<_MonoLibrary Include="@(_MonoLibraryFixed)" />
		</ItemGroup>
	</Target>

	<Target Name="_LinkNativeExecutable"
			DependsOnTargets="_DetectSdkLocations;_ComputeTargetArchitectures;_GenerateBundleName;_CompileNativeExecutable;_CompileAppManifest;_UpdateDynamicLibraryId"
			Inputs="@(_NativeExecutableObjectFiles)"
			Outputs="$(_IntermediateNativeLibraryDir)$(_NativeExecutableName)"
		>

		<PropertyGroup>
			<_NativeExecutablePublishDir Condition="'$(_PlatformName)' != 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\</_NativeExecutablePublishDir>
			<_NativeExecutablePublishDir Condition="'$(_PlatformName)' == 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\Contents\MacOS\</_NativeExecutablePublishDir>
			<_DylibRPath Condition="'$(_PlatformName)' != 'macOS'">@executable_path</_DylibRPath>
			<_DylibRPath Condition="'$(_PlatformName)' == 'macOS'">@executable_path/../$(_CustomBundleName)/</_DylibRPath>
		</PropertyGroup>

		<ItemGroup>
			<_XamarinMainLibraries Include="$(_XamarinNativeLibraryDirectory)/$(_LibXamarinName)" />
			<!-- Link with the libraries shipped with the mono runtime pack -->
			<_XamarinMainLibraries Include="@(_MonoLibrary)" />
			<!-- The frameworks we need to link with (both weakly and normally) -->
			<_NativeExecutableFrameworks Include="@(_LinkerFrameworks)" />
		</ItemGroup>

		<LinkNativeCode
			SessionId="$(BuildSessionId)"
			DylibRPath="$(_DylibRPath)"
			EntitlementsInExecutable="$(_CompiledEntitlements)"
			Frameworks="@(_NativeExecutableFrameworks);@(_BindingLibraryFrameworks)"
			LinkerFlags="@(_BindingLibraryLinkerFlags)"
			LinkWithLibraries="@(_XamarinMainLibraries);@(_BindingLibraryLinkWith);@(_MainLinkWith)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			ObjectFiles="@(_NativeExecutableObjectFiles)"
			OutputFile="$(_IntermediateNativeLibraryDir)$(_NativeExecutableName)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkRoot="$(_SdkRoot)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		/>

		<ItemGroup>
			<!-- Copy the executable from the intermediate directory to the .app -->
			<ResolvedFileToPublish
				Include="$(_IntermediateNativeLibraryDir)$(_NativeExecutableName)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(_NativeExecutablePublishDir)))\$(_NativeExecutableName)"/>
		</ItemGroup>
	</Target>

	<Target Name="_ComputeDefaultLinkMode" DependsOnTargets="_DetectSdkLocations">
		<PropertyGroup>
			<_DefaultLinkMode Condition="'$(_PlatformName)' == 'macOS'">None</_DefaultLinkMode> <!-- Linking is off by default for macOS apps -->
			<_DefaultLinkMode Condition="'$(_PlatformName)' != 'macOS' And '$(_SdkIsSimulator)' == 'true'">None</_DefaultLinkMode> <!-- Linking is off by default in the simulator -->
			<_DefaultLinkMode Condition="'$(_PlatformName)' != 'macOS' And '$(_SdkIsSimulator)' != 'true'">SdkOnly</_DefaultLinkMode> <!-- Linking is SdkOnly for iOS/tvOS/watchOS apps on device -->
		</PropertyGroup>
	</Target>
	<PropertyGroup>
		<_ComputeLinkModeDependsOn>
			$(_ComputeLinkModeDependsOn);
			_ComputeDefaultLinkMode;
		</_ComputeLinkModeDependsOn>
	</PropertyGroup>

	<Target Name="_ComputePublishLocation" DependsOnTargets="_GenerateBundleName;_ParseBundlerArguments">
		<!-- Put .dll, .pdb, .exe and .dylib in the .app -->
		<PropertyGroup>
			<_AssemblyPublishDir Condition="'$(_PlatformName)' != 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\</_AssemblyPublishDir>
			<_AssemblyPublishDir Condition="'$(_PlatformName)' == 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\Contents\$(_CustomBundleName)\</_AssemblyPublishDir>
			<_DylibPublishDir Condition="'$(_PlatformName)' != 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\</_DylibPublishDir>
			<_DylibPublishDir Condition="'$(_PlatformName)' == 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\Contents\$(_CustomBundleName)\</_DylibPublishDir>
		</PropertyGroup>
		<ItemGroup>
			<ResolvedFileToPublish
				Update="@(ResolvedFileToPublish)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(_AssemblyPublishDir)))%(ResolvedFileToPublish.DestinationSubDirectory)%(Filename)%(Extension)"
				Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.pdb' Or '%(Extension)' == '.exe'" />
			<!-- Copy the app.config file to the app bundle -->
			<ResolvedFileToPublish
				Update="@(ResolvedFileToPublish)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(_AssemblyPublishDir)))%(ResolvedFileToPublish.DestinationSubDirectory)%(ResolvedFileToPublish.TargetPath)"
				Condition="'$(AppConfig)' != '' And '%(ResolvedFileToPublish.OriginalItemSpec)' == '$(AppConfig)' And '%(ResolvedFileToPublish.Link)' == 'app.config' And '%(ResolvedFileToPublish.TargetPath)' != ''" />
			<ResolvedFileToPublish
				Update="@(ResolvedFileToPublish)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(_DylibPublishDir)))%(Filename)%(Extension)"
				Condition="'%(Extension)' == '.dylib'" />
		</ItemGroup>
	</Target>

	<!-- Install & Run -->

	<PropertyGroup>
		<_MlaunchPath Condition="'$(_MlaunchPath)' == ''">$(_XamarinSdkRootDirectory)tools\bin\mlaunch</_MlaunchPath>
	</PropertyGroup>

	<Target Name="_InstallMobile" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName" Condition="'$(_SdkIsSimulator)' == 'false'">
		<GetMlaunchArguments
			SessionId="$(BuildSessionId)"
			AppBundlePath="$(_AppBundlePath)"
			AppManifestPath="$(_AppBundlePath)$(_AppBundleManifestRelativePath)Info.plist"
			DeviceName="$(_DeviceName)"
			InstallApp="$(_AppBundlePath)"
			MlaunchPath="$(_MlaunchPath)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		>
			<Output TaskParameter="MlaunchArguments" PropertyName="_MlaunchInstallArguments" />
		</GetMlaunchArguments>

		<Exec Command="$(_MlaunchPath) $(_MlaunchInstallArguments)" />
	</Target>

	<Target Name="_PrepareRunMobile" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName;_InstallMobile" >
		<PropertyGroup>
			<!-- capture output by default -->
			<_MlaunchCaptureOutput Condition="'$(_MlaunchCaptureOutput)' == ''">true</_MlaunchCaptureOutput>
			<!-- wait for exit by default -->
			<_MlaunchWaitForExit Condition="'$(_MlaunchWaitForExit)' == ''">true</_MlaunchWaitForExit>
			<!-- don't set standard output/error path, mlaunch will by default write to stdout/stderr -->
		</PropertyGroup>
		<GetMlaunchArguments
			SessionId="$(BuildSessionId)"
			AppBundlePath="$(_AppBundlePath)"
			AppManifestPath="$(_AppBundlePath)$(_AppBundleManifestRelativePath)Info.plist"
			CaptureOutput="$(_MlaunchCaptureOutput)"
			DeviceName="$(_DeviceName)"
			LaunchApp="$(_AppBundlePath)"
			MlaunchPath="$(_MlaunchPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkDevPath="$(_SdkDevPath)"
			SdkVersion="$(_SdkVersion)"
			StandardErrorPath="$(_MlaunchStandardErrorPath)"
			StandardOutputPath="$(_MlaunchStandardOutputPath)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			WaitForExit="$(_MlaunchWaitForExit)"
		>
			<Output TaskParameter="MlaunchArguments" PropertyName="_MlaunchRunArguments" />
		</GetMlaunchArguments>

		<PropertyGroup>
			<RunCommand>$(_MlaunchPath)</RunCommand>
			<RunArguments>$(_MlaunchRunArguments)</RunArguments>
		</PropertyGroup>
	</Target>

	<!-- This is only needed for mobile platforms, RunCommand and RunArguments are defined for macOS in Microsoft.macOS.Sdk.targets. -->
	<Target Name="_PrepareRun" DependsOnTargets="_PrepareRunMobile" BeforeTargets="Run" Condition="'$(_PlatformName)' != 'macOS'" />

	<!-- Import existing targets -->

	<PropertyGroup>
		<_ProjectLanguage>$(Language)</_ProjectLanguage>
		<_ProjectLanguage Condition="'$(_ProjectLanguage)' == '' Or '$(_ProjectLanguage)' == 'C#' ">CSharp</_ProjectLanguage>
		<_ProjectLanguage Condition="'$(_ProjectLanguage)' == 'F#' ">FSharp</_ProjectLanguage>

		<_TargetsDirectory>$(_XamarinSdkRootDirectory)\tools\msbuild\$(_PlatformName)\</_TargetsDirectory>
	</PropertyGroup>

	<Import Project="$(_TargetsDirectory)Xamarin.iOS.$(_ProjectLanguage).targets"                  Condition="'$(_ProjectType)' == 'iOSExecutableProject' Or '$(_ProjectType)' == 'iOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.iOS.AppExtension.$(_ProjectLanguage).targets"     Condition="'$(_ProjectType)' == 'iOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.iOS.ObjCBinding.$(_ProjectLanguage).targets"      Condition="'$(_ProjectType)' == 'iOSBindingProject' " />

	<Import Project="$(_TargetsDirectory)Xamarin.TVOS.$(_ProjectLanguage).targets"                 Condition="'$(_ProjectType)' == 'tvOSExecutableProject' Or '$(_ProjectType)' == 'tvOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.TVOS.AppExtension.$(_ProjectLanguage).targets"    Condition="'$(_ProjectType)' == 'tvOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.TVOS.ObjCBinding.$(_ProjectLanguage).targets"     Condition="'$(_ProjectType)' == 'tvOSBindingProject' " />

	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.$(_ProjectLanguage).targets"              Condition="'$(_ProjectType)' == 'watchOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.App.$(_ProjectLanguage).targets"          Condition="'$(_ProjectType)' == 'watchOSAppProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.AppExtension.$(_ProjectLanguage).targets" Condition="'$(_ProjectType)' == 'watchOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.ObjCBinding.$(_ProjectLanguage).targets"  Condition="'$(_ProjectType)' == 'watchOSBindingProject' " />

	<Import Project="$(_TargetsDirectory)Xamarin.Mac.$(_ProjectLanguage).targets"                  Condition="'$(_ProjectType)' == 'macOSExecutableProject' Or '$(_ProjectType)' == 'macOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.Mac.AppExtension.$(_ProjectLanguage).targets"     Condition="'$(_ProjectType)' == 'macOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.Mac.ObjCBinding.$(_ProjectLanguage).targets"      Condition="'$(_ProjectType)' == 'macOSBindingProject' " />
</Project>
